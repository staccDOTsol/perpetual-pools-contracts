{
  "address": "0xbc4e49e45314bA5fec91851A71cFfbe02D2d1C93",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_factory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "name": "FactoryChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        }
      ],
      "name": "GasPriceChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "keeper",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "KeeperPaid",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "keeper",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "expectedReward",
          "type": "uint256"
        }
      ],
      "name": "KeeperPaymentError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldKeeperRewards",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newKeeperRewards",
          "type": "address"
        }
      ],
      "name": "KeeperRewardsSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "int256",
          "name": "firstPrice",
          "type": "int256"
        }
      ],
      "name": "PoolAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "PoolUpkeepError",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        },
        {
          "indexed": true,
          "internalType": "int256",
          "name": "startPrice",
          "type": "int256"
        },
        {
          "indexed": true,
          "internalType": "int256",
          "name": "endPrice",
          "type": "int256"
        }
      ],
      "name": "UpkeepSuccessful",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_pools",
          "type": "address[]"
        }
      ],
      "name": "checkUpkeepMultiplePools",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "executionPrice",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "contract IPoolFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gasPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        }
      ],
      "name": "isUpkeepRequiredSinglePool",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "keeperRewards",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_poolAddress",
          "type": "address"
        }
      ],
      "name": "newPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "pools",
          "type": "address[]"
        }
      ],
      "name": "performUpkeepMultiplePools",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "pools",
          "type": "bytes"
        }
      ],
      "name": "performUpkeepMultiplePoolsPacked",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pool",
          "type": "address"
        }
      ],
      "name": "performUpkeepSinglePool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_price",
          "type": "uint256"
        }
      ],
      "name": "setGasPrice",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_keeperRewards",
          "type": "address"
        }
      ],
      "name": "setKeeperRewards",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xeec4709f993ea3a4bc7a4c016237657b9b1c2efc6b88825e651d7e5750c7aebb",
  "receipt": {
    "to": null,
    "from": "0xd9c281C5501c3Fe2C95587A99C9d0a54dDa63712",
    "contractAddress": "0xbc4e49e45314bA5fec91851A71cFfbe02D2d1C93",
    "transactionIndex": 1,
    "gasUsed": "2315284",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000004000008000000000001000000000000000000000000000000000000020000000000000000000804000000000000000000000000000000400100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020040000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbd2caa4441f135de58d11c8f39c100a7b03c599bf718b73cfe162c81706f1c8c",
    "transactionHash": "0xeec4709f993ea3a4bc7a4c016237657b9b1c2efc6b88825e651d7e5750c7aebb",
    "logs": [
      {
        "transactionIndex": 1,
        "blockNumber": 194565043,
        "transactionHash": "0xeec4709f993ea3a4bc7a4c016237657b9b1c2efc6b88825e651d7e5750c7aebb",
        "address": "0xbc4e49e45314bA5fec91851A71cFfbe02D2d1C93",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000d9c281c5501c3fe2c95587a99c9d0a54dda63712"
        ],
        "data": "0x",
        "logIndex": 0,
        "blockHash": "0xbd2caa4441f135de58d11c8f39c100a7b03c599bf718b73cfe162c81706f1c8c"
      }
    ],
    "blockNumber": 194565043,
    "cumulativeGasUsed": "2315284",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x66C56EC04090e06FacB943b77200f318D3d78f7b"
  ],
  "solcInputHash": "c531ec4aa0c6e728e159c9fdfa70dead",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"FactoryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"GasPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keeper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expectedReward\",\"type\":\"uint256\"}],\"name\":\"KeeperPaymentError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldKeeperRewards\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newKeeperRewards\",\"type\":\"address\"}],\"name\":\"KeeperRewardsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"firstPrice\",\"type\":\"int256\"}],\"name\":\"PoolAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"PoolUpkeepError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"startPrice\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"endPrice\",\"type\":\"int256\"}],\"name\":\"UpkeepSuccessful\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_pools\",\"type\":\"address[]\"}],\"name\":\"checkUpkeepMultiplePools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"executionPrice\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IPoolFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"isUpkeepRequiredSinglePool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeperRewards\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"newPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"pools\",\"type\":\"address[]\"}],\"name\":\"performUpkeepMultiplePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"pools\",\"type\":\"bytes\"}],\"name\":\"performUpkeepMultiplePoolsPacked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"performUpkeepSinglePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setGasPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keeperRewards\",\"type\":\"address\"}],\"name\":\"setKeeperRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Currently, this contract estimates the best keeper rewards in a way that is best suited for Ethereum L1.It assumes an approximate block time of 13 seconds, and an Ethereum-like gas system.This code was also written with Arbitrum deployment in mind, meaning there exists no `block.basefee`, and no arbitrum gas price oracle.It has another large drawback in that it is not possible to calculate the cost of the current transaction Arbitrum, given that the cost is largely determined by L1 calldata cost.Because of this, the reward calculation is an rough \\\"good enough\\\" estimation.\",\"kind\":\"dev\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"details\":\"Iterates over the provided array of pool addresses\",\"params\":{\"_pools\":\"Array of pools to check\"},\"returns\":{\"_0\":\"Whether or not at least one pool needs upkeeping\"}},\"isUpkeepRequiredSinglePool(address)\":{\"params\":{\"_pool\":\"The address of the pool to upkeep\"},\"returns\":{\"_0\":\"Whether or not upkeep is needed for this single pool\"}},\"newPool(address)\":{\"details\":\"Only callable by the associated `PoolFactory` contract\",\"params\":{\"_poolAddress\":\"The address of the newly-created pools\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"performUpkeepMultiplePools(address[])\":{\"details\":\"Iterates over the provided arrayEssentially wraps calls to `performUpkeepSinglePool`\",\"params\":{\"pools\":\"Addresses of each pool to upkeep\"}},\"performUpkeepMultiplePoolsPacked(bytes)\":{\"details\":\"Arguments can be encoded with `L2Encoder.encodeAddressArray`Will revert if the bytes array is a correct length (some multiple of 20 bytes)\",\"params\":{\"pools\":\"A tightly packed bytes array of LeveragedPool addresses to be upkept  __________________________________________________ |   20 bytes       20 bytes       20 bytes     ... | | pool address | pool address | pool address | ... |  \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\"}},\"performUpkeepSinglePool(address)\":{\"details\":\"Tracks gas usage via `gasleft` accounting and uses this to inform          keeper paymentCatches any failure of the underlying `pool.poolUpkeep` callEmits a `KeeperPaid` event if the underlying call to `pool.payKeeperFromBalances` succeedsEmits a `KeeperPaymentError` event otherwise\",\"params\":{\"_pool\":\"Address of the pool to be upkept\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setGasPrice(uint256)\":{\"details\":\"Only callable by the ownerThis function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`Emits a `GasPriceChanged` event on success\",\"params\":{\"_price\":\"Price (in ETH) per unit gas\"}},\"setKeeperRewards(address)\":{\"details\":\"Only callable by the contract owneremits KeeperRewardsSet when the addresss is successfuly changed\",\"params\":{\"_keeperRewards\":\"The new KeeperRewards contract\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"title\":\"The manager contract for multiple markets and the pools in them\",\"version\":1},\"userdoc\":{\"events\":{\"FactoryChanged(address)\":{\"notice\":\"Indicates that the factory address has changed\"},\"GasPriceChanged(uint256)\":{\"notice\":\"Indicates that the gas price for keeper rewards changed\"},\"KeeperPaid(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper is paid for doing upkeep for a pool\"},\"KeeperPaymentError(address,address,uint256)\":{\"notice\":\"Creates a notification when a keeper's payment for upkeeping a pool failed\"},\"KeeperRewardsSet(address,address)\":{\"notice\":\"Indicates that the KeeperRewards contract has\"},\"PoolAdded(address,int256)\":{\"notice\":\"Creates a notification when a pool is created\"},\"PoolUpkeepError(address,string)\":{\"notice\":\"Creates a notification of a failed pool update\"},\"UpkeepSuccessful(address,bytes,int256,int256)\":{\"notice\":\"Creates a notification when a call to LeveragedPool:poolUpkeep is successful\"}},\"kind\":\"user\",\"methods\":{\"checkUpkeepMultiplePools(address[])\":{\"notice\":\"Checks multiple pools if any of them need updating\"},\"executionPrice(address)\":{\"notice\":\"Format: Pool address => last executionPrice\"},\"isUpkeepRequiredSinglePool(address)\":{\"notice\":\"Check if upkeep is required\"},\"newPool(address)\":{\"notice\":\"When a pool is created, this function is called by the factory to initiate price trackings\"},\"performUpkeepMultiplePools(address[])\":{\"notice\":\"Called by keepers to perform an update on multiple pools\"},\"performUpkeepMultiplePoolsPacked(bytes)\":{\"notice\":\"Called by keepers to perform an update on multiple pools\"},\"performUpkeepSinglePool(address)\":{\"notice\":\"Called by keepers to perform an update on a single pool\"},\"setGasPrice(uint256)\":{\"notice\":\"Sets the gas price to be used in compensating keepers for successful upkeep\"},\"setKeeperRewards(address)\":{\"notice\":\"Changes the KeeperRewards contract, used for calculating and executing rewards for calls to upkeep functions\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/PoolKeeper.sol\":\"PoolKeeper\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x6bb804a310218875e89d12c053e94a13a4607cdf7cc2052f3e52bd32a0dc50a1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x95098bd1d9c8dec4d80d3dedb88a0d949fa0d740ee99f2aa466bc308216ca6d5\",\"license\":\"MIT\"},\"abdk-libraries-solidity/ABDKMathQuad.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-4-Clause\\n/*\\n * ABDK Math Quad Smart Contract Library.  Copyright \\u00a9 2019 by ABDK Consulting.\\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\\n */\\npragma solidity ^0.8.0;\\n\\n/**\\n * Smart contract library of mathematical functions operating with IEEE 754\\n * quadruple-precision binary floating-point numbers (quadruple precision\\n * numbers).  As long as quadruple precision numbers are 16-bytes long, they are\\n * represented by bytes16 type.\\n */\\nlibrary ABDKMathQuad {\\n  /*\\n   * 0.\\n   */\\n  bytes16 private constant POSITIVE_ZERO = 0x00000000000000000000000000000000;\\n\\n  /*\\n   * -0.\\n   */\\n  bytes16 private constant NEGATIVE_ZERO = 0x80000000000000000000000000000000;\\n\\n  /*\\n   * +Infinity.\\n   */\\n  bytes16 private constant POSITIVE_INFINITY = 0x7FFF0000000000000000000000000000;\\n\\n  /*\\n   * -Infinity.\\n   */\\n  bytes16 private constant NEGATIVE_INFINITY = 0xFFFF0000000000000000000000000000;\\n\\n  /*\\n   * Canonical NaN value.\\n   */\\n  bytes16 private constant NaN = 0x7FFF8000000000000000000000000000;\\n\\n  /**\\n   * Convert signed 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x signed 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromInt (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 256-bit integer number\\n   * rounding towards zero.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 256-bit integer number\\n   */\\n  function toInt (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16638); // Overflow\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert unsigned 256-bit integer number into quadruple precision number.\\n   *\\n   * @param x unsigned 256-bit integer number\\n   * @return quadruple precision number\\n   */\\n  function fromUInt (uint256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        uint256 result = x;\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16383 + msb << 112;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into unsigned 256-bit integer number\\n   * rounding towards zero.  Revert on underflow.  Note, that negative floating\\n   * point numbers in range (-1.0 .. 0.0) may be converted to unsigned integer\\n   * without error, because they are rounded to zero.\\n   *\\n   * @param x quadruple precision number\\n   * @return unsigned 256-bit integer number\\n   */\\n  function toUInt (bytes16 x) internal pure returns (uint256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      if (exponent < 16383) return 0; // Underflow\\n\\n      require (uint128 (x) < 0x80000000000000000000000000000000); // Negative\\n\\n      require (exponent <= 16638); // Overflow\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16495) result >>= 16495 - exponent;\\n      else if (exponent > 16495) result <<= exponent - 16495;\\n\\n      return result;\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 128.128 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 128.128 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from128x128 (int256 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint256 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16255 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 128.128 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 128.128 bit fixed point number\\n   */\\n  function to128x128 (bytes16 x) internal pure returns (int256) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16510); // Overflow\\n      if (exponent < 16255) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16367) result >>= 16367 - exponent;\\n      else if (exponent > 16367) result <<= exponent - 16367;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x8000000000000000000000000000000000000000000000000000000000000000);\\n        return -int256 (result); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int256 (result);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert signed 64.64 bit fixed point number into quadruple precision\\n   * number.\\n   *\\n   * @param x signed 64.64 bit fixed point number\\n   * @return quadruple precision number\\n   */\\n  function from64x64 (int128 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (x == 0) return bytes16 (0);\\n      else {\\n        // We rely on overflow behavior here\\n        uint256 result = uint128 (x > 0 ? x : -x);\\n\\n        uint256 msb = mostSignificantBit (result);\\n        if (msb < 112) result <<= 112 - msb;\\n        else if (msb > 112) result >>= msb - 112;\\n\\n        result = result & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF | 16319 + msb << 112;\\n        if (x < 0) result |= 0x80000000000000000000000000000000;\\n\\n        return bytes16 (uint128 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into signed 64.64 bit fixed point\\n   * number.  Revert on overflow.\\n   *\\n   * @param x quadruple precision number\\n   * @return signed 64.64 bit fixed point number\\n   */\\n  function to64x64 (bytes16 x) internal pure returns (int128) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      require (exponent <= 16446); // Overflow\\n      if (exponent < 16319) return 0; // Underflow\\n\\n      uint256 result = uint256 (uint128 (x)) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF |\\n        0x10000000000000000000000000000;\\n\\n      if (exponent < 16431) result >>= 16431 - exponent;\\n      else if (exponent > 16431) result <<= exponent - 16431;\\n\\n      if (uint128 (x) >= 0x80000000000000000000000000000000) { // Negative\\n        require (result <= 0x80000000000000000000000000000000);\\n        return -int128 (int256 (result)); // We rely on overflow behavior here\\n      } else {\\n        require (result <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n        return int128 (int256 (result));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Convert octuple precision number into quadruple precision number.\\n   *\\n   * @param x octuple precision number\\n   * @return quadruple precision number\\n   */\\n  function fromOctuple (bytes32 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool negative = x & 0x8000000000000000000000000000000000000000000000000000000000000000 > 0;\\n\\n      uint256 exponent = uint256 (x) >> 236 & 0x7FFFF;\\n      uint256 significand = uint256 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFFF) {\\n        if (significand > 0) return NaN;\\n        else return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      }\\n\\n      if (exponent > 278526)\\n        return negative ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n      else if (exponent < 245649)\\n        return negative ? NEGATIVE_ZERO : POSITIVE_ZERO;\\n      else if (exponent < 245761) {\\n        significand = (significand | 0x100000000000000000000000000000000000000000000000000000000000) >> 245885 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 124;\\n        exponent -= 245760;\\n      }\\n\\n      uint128 result = uint128 (significand | exponent << 112);\\n      if (negative) result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into octuple precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return octuple precision number\\n   */\\n  function toOctuple (bytes16 x) internal pure returns (bytes32) {\\n    unchecked {\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n\\n      uint256 result = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) exponent = 0x7FFFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 236 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 245649 + msb;\\n        }\\n      } else {\\n        result <<= 124;\\n        exponent += 245760;\\n      }\\n\\n      result |= exponent << 236;\\n      if (uint128 (x) >= 0x80000000000000000000000000000000)\\n        result |= 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n      return bytes32 (result);\\n    }\\n  }\\n\\n  /**\\n   * Convert double precision number into quadruple precision number.\\n   *\\n   * @param x double precision number\\n   * @return quadruple precision number\\n   */\\n  function fromDouble (bytes8 x) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 exponent = uint64 (x) >> 52 & 0x7FF;\\n\\n      uint256 result = uint64 (x) & 0xFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FF) exponent = 0x7FFF; // Infinity or NaN\\n      else if (exponent == 0) {\\n        if (result > 0) {\\n          uint256 msb = mostSignificantBit (result);\\n          result = result << 112 - msb & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          exponent = 15309 + msb;\\n        }\\n      } else {\\n        result <<= 60;\\n        exponent += 15360;\\n      }\\n\\n      result |= exponent << 112;\\n      if (x & 0x8000000000000000 > 0)\\n        result |= 0x80000000000000000000000000000000;\\n\\n      return bytes16 (uint128 (result));\\n    }\\n  }\\n\\n  /**\\n   * Convert quadruple precision number into double precision number.\\n   *\\n   * @param x quadruple precision number\\n   * @return double precision number\\n   */\\n  function toDouble (bytes16 x) internal pure returns (bytes8) {\\n    unchecked {\\n      bool negative = uint128 (x) >= 0x80000000000000000000000000000000;\\n\\n      uint256 exponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 significand = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (exponent == 0x7FFF) {\\n        if (significand > 0) return 0x7FF8000000000000; // NaN\\n        else return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      }\\n\\n      if (exponent > 17406)\\n        return negative ?\\n            bytes8 (0xFFF0000000000000) : // -Infinity\\n            bytes8 (0x7FF0000000000000); // Infinity\\n      else if (exponent < 15309)\\n        return negative ?\\n            bytes8 (0x8000000000000000) : // -0\\n            bytes8 (0x0000000000000000); // 0\\n      else if (exponent < 15361) {\\n        significand = (significand | 0x10000000000000000000000000000) >> 15421 - exponent;\\n        exponent = 0;\\n      } else {\\n        significand >>= 60;\\n        exponent -= 15360;\\n      }\\n\\n      uint64 result = uint64 (significand | exponent << 52);\\n      if (negative) result |= 0x8000000000000000;\\n\\n      return bytes8 (result);\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is NaN, false otherwise\\n   */\\n  function isNaN (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF >\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Test whether given quadruple precision number is positive or negative\\n   * infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @return true if x is positive or negative infinity, false otherwise\\n   */\\n  function isInfinity (bytes16 x) internal pure returns (bool) {\\n    unchecked {\\n      return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ==\\n        0x7FFF0000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign of x, i.e. -1 if x is negative, 0 if x if zero, and 1 if x\\n   * is positive.  Note that sign (-0) is zero.  Revert if x is NaN. \\n   *\\n   * @param x quadruple precision number\\n   * @return sign of x\\n   */\\n  function sign (bytes16 x) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      if (absoluteX == 0) return 0;\\n      else if (uint128 (x) >= 0x80000000000000000000000000000000) return -1;\\n      else return 1;\\n    }\\n  }\\n\\n  /**\\n   * Calculate sign (x - y).  Revert if either argument is NaN, or both\\n   * arguments are infinities of the same sign. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return sign (x - y)\\n   */\\n  function cmp (bytes16 x, bytes16 y) internal pure returns (int8) {\\n    unchecked {\\n      uint128 absoluteX = uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteX <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      uint128 absoluteY = uint128 (y) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      require (absoluteY <= 0x7FFF0000000000000000000000000000); // Not NaN\\n\\n      // Not infinities of the same sign\\n      require (x != y || absoluteX < 0x7FFF0000000000000000000000000000);\\n\\n      if (x == y) return 0;\\n      else {\\n        bool negativeX = uint128 (x) >= 0x80000000000000000000000000000000;\\n        bool negativeY = uint128 (y) >= 0x80000000000000000000000000000000;\\n\\n        if (negativeX) {\\n          if (negativeY) return absoluteX > absoluteY ? -1 : int8 (1);\\n          else return -1; \\n        } else {\\n          if (negativeY) return 1;\\n          else return absoluteX > absoluteY ? int8 (1) : -1;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Test whether x equals y.  NaN, infinity, and -infinity are not equal to\\n   * anything. \\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return true if x equals to y, false otherwise\\n   */\\n  function eq (bytes16 x, bytes16 y) internal pure returns (bool) {\\n    unchecked {\\n      if (x == y) {\\n        return uint128 (x) & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF <\\n          0x7FFF0000000000000000000000000000;\\n      } else return false;\\n    }\\n  }\\n\\n  /**\\n   * Calculate x + y.  Special values behave in the following way:\\n   *\\n   * NaN + x = NaN for any x.\\n   * Infinity + x = Infinity for any finite x.\\n   * -Infinity + x = -Infinity for any finite x.\\n   * Infinity + Infinity = Infinity.\\n   * -Infinity + -Infinity = -Infinity.\\n   * Infinity + -Infinity = -Infinity + Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function add (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) { \\n          if (x == y) return x;\\n          else return NaN;\\n        } else return x; \\n      } else if (yExponent == 0x7FFF) return y;\\n      else {\\n        bool xSign = uint128 (x) >= 0x80000000000000000000000000000000;\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        bool ySign = uint128 (y) >= 0x80000000000000000000000000000000;\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        if (xSignifier == 0) return y == NEGATIVE_ZERO ? POSITIVE_ZERO : y;\\n        else if (ySignifier == 0) return x == NEGATIVE_ZERO ? POSITIVE_ZERO : x;\\n        else {\\n          int256 delta = int256 (xExponent) - int256 (yExponent);\\n  \\n          if (xSign == ySign) {\\n            if (delta > 112) return x;\\n            else if (delta > 0) ySignifier >>= uint256 (delta);\\n            else if (delta < -112) return y;\\n            else if (delta < 0) {\\n              xSignifier >>= uint256 (-delta);\\n              xExponent = yExponent;\\n            }\\n  \\n            xSignifier += ySignifier;\\n  \\n            if (xSignifier >= 0x20000000000000000000000000000) {\\n              xSignifier >>= 1;\\n              xExponent += 1;\\n            }\\n  \\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else {\\n              if (xSignifier < 0x10000000000000000000000000000) xExponent = 0;\\n              else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  \\n              return bytes16 (uint128 (\\n                  (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                  (xExponent << 112) |\\n                  xSignifier)); \\n            }\\n          } else {\\n            if (delta > 0) {\\n              xSignifier <<= 1;\\n              xExponent -= 1;\\n            } else if (delta < 0) {\\n              ySignifier <<= 1;\\n              xExponent = yExponent - 1;\\n            }\\n\\n            if (delta > 112) ySignifier = 1;\\n            else if (delta > 1) ySignifier = (ySignifier - 1 >> uint256 (delta - 1)) + 1;\\n            else if (delta < -112) xSignifier = 1;\\n            else if (delta < -1) xSignifier = (xSignifier - 1 >> uint256 (-delta - 1)) + 1;\\n\\n            if (xSignifier >= ySignifier) xSignifier -= ySignifier;\\n            else {\\n              xSignifier = ySignifier - xSignifier;\\n              xSign = ySign;\\n            }\\n\\n            if (xSignifier == 0)\\n              return POSITIVE_ZERO;\\n\\n            uint256 msb = mostSignificantBit (xSignifier);\\n\\n            if (msb == 113) {\\n              xSignifier = xSignifier >> 1 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n              xExponent += 1;\\n            } else if (msb < 112) {\\n              uint256 shift = 112 - msb;\\n              if (xExponent > shift) {\\n                xSignifier = xSignifier << shift & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n                xExponent -= shift;\\n              } else {\\n                xSignifier <<= xExponent - 1;\\n                xExponent = 0;\\n              }\\n            } else xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n            if (xExponent == 0x7FFF)\\n              return xSign ? NEGATIVE_INFINITY : POSITIVE_INFINITY;\\n            else return bytes16 (uint128 (\\n                (xSign ? 0x80000000000000000000000000000000 : 0) |\\n                (xExponent << 112) |\\n                xSignifier));\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x - y.  Special values behave in the following way:\\n   *\\n   * NaN - x = NaN for any x.\\n   * Infinity - x = Infinity for any finite x.\\n   * -Infinity - x = -Infinity for any finite x.\\n   * Infinity - -Infinity = Infinity.\\n   * -Infinity - Infinity = -Infinity.\\n   * Infinity - Infinity = -Infinity - -Infinity = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sub (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      return add (x, y ^ 0x80000000000000000000000000000000);\\n    }\\n  }\\n\\n  /**\\n   * Calculate x * y.  Special values behave in the following way:\\n   *\\n   * NaN * x = NaN for any x.\\n   * Infinity * x = Infinity for any finite positive x.\\n   * Infinity * x = -Infinity for any finite negative x.\\n   * -Infinity * x = -Infinity for any finite positive x.\\n   * -Infinity * x = Infinity for any finite negative x.\\n   * Infinity * 0 = NaN.\\n   * -Infinity * 0 = NaN.\\n   * Infinity * Infinity = Infinity.\\n   * Infinity * -Infinity = -Infinity.\\n   * -Infinity * Infinity = -Infinity.\\n   * -Infinity * -Infinity = Infinity.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function mul (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) {\\n          if (x == y) return x ^ y & 0x80000000000000000000000000000000;\\n          else if (x ^ y == 0x80000000000000000000000000000000) return x | y;\\n          else return NaN;\\n        } else {\\n          if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return x ^ y & 0x80000000000000000000000000000000;\\n        }\\n      } else if (yExponent == 0x7FFF) {\\n          if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n          else return y ^ x & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        xSignifier *= ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        xExponent += yExponent;\\n\\n        uint256 msb =\\n          xSignifier >= 0x200000000000000000000000000000000000000000000000000000000 ? 225 :\\n          xSignifier >= 0x100000000000000000000000000000000000000000000000000000000 ? 224 :\\n          mostSignificantBit (xSignifier);\\n\\n        if (xExponent + msb < 16496) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb < 16608) { // Subnormal\\n          if (xExponent < 16496)\\n            xSignifier >>= 16496 - xExponent;\\n          else if (xExponent > 16496)\\n            xSignifier <<= xExponent - 16496;\\n          xExponent = 0;\\n        } else if (xExponent + msb > 49373) {\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else {\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n          else if (msb < 112)\\n            xSignifier <<= 112 - msb;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb - 16607;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate x / y.  Special values behave in the following way:\\n   *\\n   * NaN / x = NaN for any x.\\n   * x / NaN = NaN for any x.\\n   * Infinity / x = Infinity for any finite non-negative x.\\n   * Infinity / x = -Infinity for any finite negative x including -0.\\n   * -Infinity / x = -Infinity for any finite non-negative x.\\n   * -Infinity / x = Infinity for any finite negative x including -0.\\n   * x / Infinity = 0 for any finite non-negative x.\\n   * x / -Infinity = -0 for any finite non-negative x.\\n   * x / Infinity = -0 for any finite non-negative x including -0.\\n   * x / -Infinity = 0 for any finite non-negative x including -0.\\n   * \\n   * Infinity / Infinity = NaN.\\n   * Infinity / -Infinity = -NaN.\\n   * -Infinity / Infinity = -NaN.\\n   * -Infinity / -Infinity = NaN.\\n   *\\n   * Division by zero behaves in the following way:\\n   *\\n   * x / 0 = Infinity for any finite positive x.\\n   * x / -0 = -Infinity for any finite positive x.\\n   * x / 0 = -Infinity for any finite negative x.\\n   * x / -0 = Infinity for any finite negative x.\\n   * 0 / 0 = NaN.\\n   * 0 / -0 = NaN.\\n   * -0 / 0 = NaN.\\n   * -0 / -0 = NaN.\\n   *\\n   * @param x quadruple precision number\\n   * @param y quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function div (bytes16 x, bytes16 y) internal pure returns (bytes16) {\\n    unchecked {\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 yExponent = uint128 (y) >> 112 & 0x7FFF;\\n\\n      if (xExponent == 0x7FFF) {\\n        if (yExponent == 0x7FFF) return NaN;\\n        else return x ^ y & 0x80000000000000000000000000000000;\\n      } else if (yExponent == 0x7FFF) {\\n        if (y & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF != 0) return NaN;\\n        else return POSITIVE_ZERO | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else if (y & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) {\\n        if (x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) return NaN;\\n        else return POSITIVE_INFINITY | (x ^ y) & 0x80000000000000000000000000000000;\\n      } else {\\n        uint256 ySignifier = uint128 (y) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (yExponent == 0) yExponent = 1;\\n        else ySignifier |= 0x10000000000000000000000000000;\\n\\n        uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xExponent == 0) {\\n          if (xSignifier != 0) {\\n            uint shift = 226 - mostSignificantBit (xSignifier);\\n\\n            xSignifier <<= shift;\\n\\n            xExponent = 1;\\n            yExponent += shift - 114;\\n          }\\n        }\\n        else {\\n          xSignifier = (xSignifier | 0x10000000000000000000000000000) << 114;\\n        }\\n\\n        xSignifier = xSignifier / ySignifier;\\n        if (xSignifier == 0)\\n          return (x ^ y) & 0x80000000000000000000000000000000 > 0 ?\\n              NEGATIVE_ZERO : POSITIVE_ZERO;\\n\\n        assert (xSignifier >= 0x1000000000000000000000000000);\\n\\n        uint256 msb =\\n          xSignifier >= 0x80000000000000000000000000000 ? mostSignificantBit (xSignifier) :\\n          xSignifier >= 0x40000000000000000000000000000 ? 114 :\\n          xSignifier >= 0x20000000000000000000000000000 ? 113 : 112;\\n\\n        if (xExponent + msb > yExponent + 16497) { // Overflow\\n          xExponent = 0x7FFF;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16380  < yExponent) { // Underflow\\n          xExponent = 0;\\n          xSignifier = 0;\\n        } else if (xExponent + msb + 16268  < yExponent) { // Subnormal\\n          if (xExponent + 16380 > yExponent)\\n            xSignifier <<= xExponent + 16380 - yExponent;\\n          else if (xExponent + 16380 < yExponent)\\n            xSignifier >>= yExponent - xExponent - 16380;\\n\\n          xExponent = 0;\\n        } else { // Normal\\n          if (msb > 112)\\n            xSignifier >>= msb - 112;\\n\\n          xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n          xExponent = xExponent + msb + 16269 - yExponent;\\n        }\\n\\n        return bytes16 (uint128 (uint128 ((x ^ y) & 0x80000000000000000000000000000000) |\\n            xExponent << 112 | xSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate -x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function neg (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x ^ 0x80000000000000000000000000000000;\\n    }\\n  }\\n\\n  /**\\n   * Calculate |x|.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function abs (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return x & 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    }\\n  }\\n\\n  /**\\n   * Calculate square root of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function sqrt (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) >  0x80000000000000000000000000000000) return NaN;\\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return POSITIVE_ZERO;\\n\\n          bool oddExponent = xExponent & 0x1 == 0;\\n          xExponent = xExponent + 16383 >> 1;\\n\\n          if (oddExponent) {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 113;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (226 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          } else {\\n            if (xSignifier >= 0x10000000000000000000000000000)\\n              xSignifier <<= 112;\\n            else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              uint256 shift = (225 - msb) & 0xFE;\\n              xSignifier <<= shift;\\n              xExponent -= shift - 112 >> 1;\\n            }\\n          }\\n\\n          uint256 r = 0x10000000000000000000000000000;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1;\\n          r = (r + xSignifier / r) >> 1; // Seven iterations should be enough\\n          uint256 r1 = xSignifier / r;\\n          if (r1 < r) r = r1;\\n\\n          return bytes16 (uint128 (xExponent << 112 | r & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate binary logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function log_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      if (uint128 (x) > 0x80000000000000000000000000000000) return NaN;\\n      else if (x == 0x3FFF0000000000000000000000000000) return POSITIVE_ZERO; \\n      else {\\n        uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n        if (xExponent == 0x7FFF) return x;\\n        else {\\n          uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          if (xExponent == 0) xExponent = 1;\\n          else xSignifier |= 0x10000000000000000000000000000;\\n\\n          if (xSignifier == 0) return NEGATIVE_INFINITY;\\n\\n          bool resultNegative;\\n          uint256 resultExponent = 16495;\\n          uint256 resultSignifier;\\n\\n          if (xExponent >= 0x3FFF) {\\n            resultNegative = false;\\n            resultSignifier = xExponent - 0x3FFF;\\n            xSignifier <<= 15;\\n          } else {\\n            resultNegative = true;\\n            if (xSignifier >= 0x10000000000000000000000000000) {\\n              resultSignifier = 0x3FFE - xExponent;\\n              xSignifier <<= 15;\\n            } else {\\n              uint256 msb = mostSignificantBit (xSignifier);\\n              resultSignifier = 16493 - msb;\\n              xSignifier <<= 127 - msb;\\n            }\\n          }\\n\\n          if (xSignifier == 0x80000000000000000000000000000000) {\\n            if (resultNegative) resultSignifier += 1;\\n            uint256 shift = 112 - mostSignificantBit (resultSignifier);\\n            resultSignifier <<= shift;\\n            resultExponent -= shift;\\n          } else {\\n            uint256 bb = resultNegative ? 1 : 0;\\n            while (resultSignifier < 0x10000000000000000000000000000) {\\n              resultSignifier <<= 1;\\n              resultExponent -= 1;\\n  \\n              xSignifier *= xSignifier;\\n              uint256 b = xSignifier >> 255;\\n              resultSignifier += b ^ bb;\\n              xSignifier >>= 127 + b;\\n            }\\n          }\\n\\n          return bytes16 (uint128 ((resultNegative ? 0x80000000000000000000000000000000 : 0) |\\n              resultExponent << 112 | resultSignifier & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF));\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate natural logarithm of x.  Return NaN on negative x excluding -0.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function ln (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return mul (log_2 (x), 0x3FFE62E42FEFA39EF35793C7673007E5);\\n    }\\n  }\\n\\n  /**\\n   * Calculate 2^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function pow_2 (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      bool xNegative = uint128 (x) > 0x80000000000000000000000000000000;\\n      uint256 xExponent = uint128 (x) >> 112 & 0x7FFF;\\n      uint256 xSignifier = uint128 (x) & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n      if (xExponent == 0x7FFF && xSignifier != 0) return NaN;\\n      else if (xExponent > 16397)\\n        return xNegative ? POSITIVE_ZERO : POSITIVE_INFINITY;\\n      else if (xExponent < 16255)\\n        return 0x3FFF0000000000000000000000000000;\\n      else {\\n        if (xExponent == 0) xExponent = 1;\\n        else xSignifier |= 0x10000000000000000000000000000;\\n\\n        if (xExponent > 16367)\\n          xSignifier <<= xExponent - 16367;\\n        else if (xExponent < 16367)\\n          xSignifier >>= 16367 - xExponent;\\n\\n        if (xNegative && xSignifier > 0x406E00000000000000000000000000000000)\\n          return POSITIVE_ZERO;\\n\\n        if (!xNegative && xSignifier > 0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n          return POSITIVE_INFINITY;\\n\\n        uint256 resultExponent = xSignifier >> 128;\\n        xSignifier &= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n        if (xNegative && xSignifier != 0) {\\n          xSignifier = ~xSignifier;\\n          resultExponent += 1;\\n        }\\n\\n        uint256 resultSignifier = 0x80000000000000000000000000000000;\\n        if (xSignifier & 0x80000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\\n        if (xSignifier & 0x400000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\\n        if (xSignifier & 0x200000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\\n        if (xSignifier & 0x100000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\\n        if (xSignifier & 0x80000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\\n        if (xSignifier & 0x40000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\\n        if (xSignifier & 0x20000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000162E525EE054754457D5995292026 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\\n        if (xSignifier & 0x8000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\\n        if (xSignifier & 0x4000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000162E43F4F831060E02D839A9D16D >> 128;\\n        if (xSignifier & 0x1000000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\\n        if (xSignifier & 0x800000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\\n        if (xSignifier & 0x400000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\\n        if (xSignifier & 0x200000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\\n        if (xSignifier & 0x100000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\\n        if (xSignifier & 0x80000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\\n        if (xSignifier & 0x40000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\\n        if (xSignifier & 0x20000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\\n        if (xSignifier & 0x10000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\\n        if (xSignifier & 0x8000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\\n        if (xSignifier & 0x4000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\\n        if (xSignifier & 0x2000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\\n        if (xSignifier & 0x1000000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\\n        if (xSignifier & 0x800000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\\n        if (xSignifier & 0x400000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\\n        if (xSignifier & 0x200000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000162E42FEFB2FED257559BDAA >> 128;\\n        if (xSignifier & 0x100000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\\n        if (xSignifier & 0x80000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\\n        if (xSignifier & 0x40000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\\n        if (xSignifier & 0x20000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\\n        if (xSignifier & 0x10000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000B17217F7D20CF927C8E94C >> 128;\\n        if (xSignifier & 0x8000000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\\n        if (xSignifier & 0x4000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000002C5C85FDF477B662B26945 >> 128;\\n        if (xSignifier & 0x2000000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000162E42FEFA3AE53369388C >> 128;\\n        if (xSignifier & 0x1000000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000B17217F7D1D351A389D40 >> 128;\\n        if (xSignifier & 0x800000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\\n        if (xSignifier & 0x400000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\\n        if (xSignifier & 0x200000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000162E42FEFA39FE95583C2 >> 128;\\n        if (xSignifier & 0x100000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\\n        if (xSignifier & 0x80000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\\n        if (xSignifier & 0x40000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000002C5C85FDF473E242EA38 >> 128;\\n        if (xSignifier & 0x20000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000162E42FEFA39F02B772C >> 128;\\n        if (xSignifier & 0x10000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\\n        if (xSignifier & 0x8000000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\\n        if (xSignifier & 0x4000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000002C5C85FDF473DEA871F >> 128;\\n        if (xSignifier & 0x2000000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000162E42FEFA39EF44D91 >> 128;\\n        if (xSignifier & 0x1000000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000B17217F7D1CF79E949 >> 128;\\n        if (xSignifier & 0x800000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\\n        if (xSignifier & 0x400000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\\n        if (xSignifier & 0x200000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000162E42FEFA39EF366F >> 128;\\n        if (xSignifier & 0x100000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000B17217F7D1CF79AFA >> 128;\\n        if (xSignifier & 0x80000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\\n        if (xSignifier & 0x40000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\\n        if (xSignifier & 0x20000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000162E42FEFA39EF358 >> 128;\\n        if (xSignifier & 0x10000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000B17217F7D1CF79AB >> 128;\\n        if (xSignifier & 0x8000000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000058B90BFBE8E7BCD5 >> 128;\\n        if (xSignifier & 0x4000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000002C5C85FDF473DE6A >> 128;\\n        if (xSignifier & 0x2000000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000162E42FEFA39EF34 >> 128;\\n        if (xSignifier & 0x1000000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000B17217F7D1CF799 >> 128;\\n        if (xSignifier & 0x800000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000058B90BFBE8E7BCC >> 128;\\n        if (xSignifier & 0x400000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000002C5C85FDF473DE5 >> 128;\\n        if (xSignifier & 0x200000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000162E42FEFA39EF2 >> 128;\\n        if (xSignifier & 0x100000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000B17217F7D1CF78 >> 128;\\n        if (xSignifier & 0x80000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000058B90BFBE8E7BB >> 128;\\n        if (xSignifier & 0x40000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000002C5C85FDF473DD >> 128;\\n        if (xSignifier & 0x20000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000162E42FEFA39EE >> 128;\\n        if (xSignifier & 0x10000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000B17217F7D1CF6 >> 128;\\n        if (xSignifier & 0x8000000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000058B90BFBE8E7A >> 128;\\n        if (xSignifier & 0x4000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000002C5C85FDF473C >> 128;\\n        if (xSignifier & 0x2000000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000162E42FEFA39D >> 128;\\n        if (xSignifier & 0x1000000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000B17217F7D1CE >> 128;\\n        if (xSignifier & 0x800000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000058B90BFBE8E6 >> 128;\\n        if (xSignifier & 0x400000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000002C5C85FDF472 >> 128;\\n        if (xSignifier & 0x200000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000162E42FEFA38 >> 128;\\n        if (xSignifier & 0x100000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000B17217F7D1B >> 128;\\n        if (xSignifier & 0x80000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000058B90BFBE8D >> 128;\\n        if (xSignifier & 0x40000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000002C5C85FDF46 >> 128;\\n        if (xSignifier & 0x20000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000162E42FEFA2 >> 128;\\n        if (xSignifier & 0x10000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000B17217F7D0 >> 128;\\n        if (xSignifier & 0x8000000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000058B90BFBE7 >> 128;\\n        if (xSignifier & 0x4000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000002C5C85FDF3 >> 128;\\n        if (xSignifier & 0x2000000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000162E42FEF9 >> 128;\\n        if (xSignifier & 0x1000000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000B17217F7C >> 128;\\n        if (xSignifier & 0x800000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000058B90BFBD >> 128;\\n        if (xSignifier & 0x400000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000002C5C85FDE >> 128;\\n        if (xSignifier & 0x200000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000162E42FEE >> 128;\\n        if (xSignifier & 0x100000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000B17217F6 >> 128;\\n        if (xSignifier & 0x80000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000058B90BFA >> 128;\\n        if (xSignifier & 0x40000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000002C5C85FC >> 128;\\n        if (xSignifier & 0x20000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000162E42FD >> 128;\\n        if (xSignifier & 0x10000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000B17217E >> 128;\\n        if (xSignifier & 0x8000000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000058B90BE >> 128;\\n        if (xSignifier & 0x4000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000002C5C85E >> 128;\\n        if (xSignifier & 0x2000000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000162E42E >> 128;\\n        if (xSignifier & 0x1000000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000B17216 >> 128;\\n        if (xSignifier & 0x800000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000058B90A >> 128;\\n        if (xSignifier & 0x400000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000002C5C84 >> 128;\\n        if (xSignifier & 0x200000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000162E41 >> 128;\\n        if (xSignifier & 0x100000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000B1720 >> 128;\\n        if (xSignifier & 0x80000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000058B8F >> 128;\\n        if (xSignifier & 0x40000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000002C5C7 >> 128;\\n        if (xSignifier & 0x20000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000162E3 >> 128;\\n        if (xSignifier & 0x10000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000B171 >> 128;\\n        if (xSignifier & 0x8000 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000058B8 >> 128;\\n        if (xSignifier & 0x4000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000002C5B >> 128;\\n        if (xSignifier & 0x2000 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000162D >> 128;\\n        if (xSignifier & 0x1000 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000B16 >> 128;\\n        if (xSignifier & 0x800 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000058A >> 128;\\n        if (xSignifier & 0x400 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000002C4 >> 128;\\n        if (xSignifier & 0x200 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000161 >> 128;\\n        if (xSignifier & 0x100 > 0) resultSignifier = resultSignifier * 0x1000000000000000000000000000000B0 >> 128;\\n        if (xSignifier & 0x80 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000057 >> 128;\\n        if (xSignifier & 0x40 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000002B >> 128;\\n        if (xSignifier & 0x20 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000015 >> 128;\\n        if (xSignifier & 0x10 > 0) resultSignifier = resultSignifier * 0x10000000000000000000000000000000A >> 128;\\n        if (xSignifier & 0x8 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000004 >> 128;\\n        if (xSignifier & 0x4 > 0) resultSignifier = resultSignifier * 0x100000000000000000000000000000001 >> 128;\\n\\n        if (!xNegative) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent += 0x3FFF;\\n        } else if (resultExponent <= 0x3FFE) {\\n          resultSignifier = resultSignifier >> 15 & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n          resultExponent = 0x3FFF - resultExponent;\\n        } else {\\n          resultSignifier = resultSignifier >> resultExponent - 16367;\\n          resultExponent = 0;\\n        }\\n\\n        return bytes16 (uint128 (resultExponent << 112 | resultSignifier));\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Calculate e^x.\\n   *\\n   * @param x quadruple precision number\\n   * @return quadruple precision number\\n   */\\n  function exp (bytes16 x) internal pure returns (bytes16) {\\n    unchecked {\\n      return pow_2 (mul (x, 0x3FFF71547652B82FE1777D0FFDA0D23A));\\n    }\\n  }\\n\\n  /**\\n   * Get index of the most significant non-zero bit in binary representation of\\n   * x.  Reverts if x is zero.\\n   *\\n   * @return index of the most significant non-zero bit in binary representation\\n   *         of x\\n   */\\n  function mostSignificantBit (uint256 x) private pure returns (uint256) {\\n    unchecked {\\n      require (x > 0);\\n\\n      uint256 result = 0;\\n\\n      if (x >= 0x100000000000000000000000000000000) { x >>= 128; result += 128; }\\n      if (x >= 0x10000000000000000) { x >>= 64; result += 64; }\\n      if (x >= 0x100000000) { x >>= 32; result += 32; }\\n      if (x >= 0x10000) { x >>= 16; result += 16; }\\n      if (x >= 0x100) { x >>= 8; result += 8; }\\n      if (x >= 0x10) { x >>= 4; result += 4; }\\n      if (x >= 0x4) { x >>= 2; result += 2; }\\n      if (x >= 0x2) result += 1; // No need to shift x anymore\\n\\n      return result;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x9694a9f6fcadd4fa917efa674de42a74b8fbab8d68924f771ea5cc5e1a301434\",\"license\":\"BSD-4-Clause\"},\"contracts/implementation/PoolKeeper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../interfaces/IPoolKeeper.sol\\\";\\nimport \\\"../interfaces/IOracleWrapper.sol\\\";\\nimport \\\"../interfaces/IPoolFactory.sol\\\";\\nimport \\\"../interfaces/ILeveragedPool.sol\\\";\\nimport \\\"../interfaces/IERC20DecimalsWrapper.sol\\\";\\nimport \\\"../interfaces/IKeeperRewards.sol\\\";\\n\\nimport \\\"../libraries/CalldataLogic.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"abdk-libraries-solidity/ABDKMathQuad.sol\\\";\\n\\n/// @title The manager contract for multiple markets and the pools in them\\n/// @dev Currently, this contract estimates the best keeper rewards in a way that is best suited for Ethereum L1.\\n/// @dev It assumes an approximate block time of 13 seconds, and an Ethereum-like gas system.\\n/// @dev This code was also written with Arbitrum deployment in mind, meaning there exists no `block.basefee`, and no arbitrum gas price oracle.\\n/// @dev It has another large drawback in that it is not possible to calculate the cost of the current transaction Arbitrum, given that the cost is largely determined by L1 calldata cost.\\n/// @dev Because of this, the reward calculation is an rough \\\"good enough\\\" estimation.\\ncontract PoolKeeper is IPoolKeeper, Ownable {\\n    // #### Global variables\\n    /**\\n     * @notice Format: Pool address => last executionPrice\\n     */\\n    mapping(address => int256) public executionPrice;\\n\\n    IPoolFactory public immutable factory;\\n    // The KeeperRewards contract permissioned to pay out pool upkeep rewards\\n    address public override keeperRewards;\\n\\n    uint256 public gasPrice = 10 gwei;\\n\\n    /**\\n     * @notice Ensures that the caller is the associated `PoolFactory` contract\\n     */\\n    modifier onlyFactory() {\\n        require(msg.sender == address(factory), \\\"Caller not factory\\\");\\n        _;\\n    }\\n\\n    // #### Functions\\n    constructor(address _factory) {\\n        require(_factory != address(0), \\\"Factory cannot be null\\\");\\n        factory = IPoolFactory(_factory);\\n    }\\n\\n    /**\\n     * @notice When a pool is created, this function is called by the factory to initiate price trackings\\n     * @param _poolAddress The address of the newly-created pools\\n     * @dev Only callable by the associated `PoolFactory` contract\\n     */\\n    function newPool(address _poolAddress) external override onlyFactory {\\n        IOracleWrapper(ILeveragedPool(_poolAddress).oracleWrapper()).poll();\\n        int256 firstPrice = ILeveragedPool(_poolAddress).getOraclePrice();\\n        require(firstPrice > 0, \\\"First price is non-positive\\\");\\n        emit PoolAdded(_poolAddress, firstPrice);\\n        executionPrice[_poolAddress] = firstPrice;\\n    }\\n\\n    /**\\n     * @notice Check if upkeep is required\\n     * @param _pool The address of the pool to upkeep\\n     * @return Whether or not upkeep is needed for this single pool\\n     */\\n    function isUpkeepRequiredSinglePool(address _pool) public view override returns (bool) {\\n        if (!factory.isValidPool(_pool)) {\\n            return false;\\n        }\\n\\n        // The update interval has passed\\n        return ILeveragedPool(_pool).intervalPassed();\\n    }\\n\\n    /**\\n     * @notice Checks multiple pools if any of them need updating\\n     * @param _pools Array of pools to check\\n     * @return Whether or not at least one pool needs upkeeping\\n     * @dev Iterates over the provided array of pool addresses\\n     */\\n    function checkUpkeepMultiplePools(address[] calldata _pools) external view override returns (bool) {\\n        uint256 poolsLength = _pools.length;\\n        for (uint256 i = 0; i < poolsLength; i = unchecked_inc(i)) {\\n            if (isUpkeepRequiredSinglePool(_pools[i])) {\\n                // One has been found that requires upkeeping\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on a single pool\\n     * @param _pool Address of the pool to be upkept\\n     * @dev Tracks gas usage via `gasleft` accounting and uses this to inform\\n     *          keeper payment\\n     * @dev Catches any failure of the underlying `pool.poolUpkeep` call\\n     * @dev Emits a `KeeperPaid` event if the underlying call to `pool.payKeeperFromBalances` succeeds\\n     * @dev Emits a `KeeperPaymentError` event otherwise\\n     */\\n    function performUpkeepSinglePool(address _pool) public override {\\n        uint256 startGas = gasleft();\\n\\n        // validate the pool, check that the interval time has passed\\n        if (!isUpkeepRequiredSinglePool(_pool)) {\\n            return;\\n        }\\n\\n        /* update SMA oracle, does nothing for spot oracles */\\n        IOracleWrapper poolOracleWrapper = IOracleWrapper(ILeveragedPool(_pool).oracleWrapper());\\n\\n        try poolOracleWrapper.poll() {} catch Error(string memory reason) {\\n            emit PoolUpkeepError(_pool, reason);\\n        }\\n\\n        (\\n            int256 latestPrice,\\n            bytes memory data,\\n            uint256 savedPreviousUpdatedTimestamp,\\n            uint256 updateInterval\\n        ) = ILeveragedPool(_pool).getUpkeepInformation();\\n\\n        // Start a new round\\n        // Get price in WAD format\\n        int256 lastExecutionPrice = executionPrice[_pool];\\n\\n        /* This allows us to still batch multiple calls to\\n         * executePriceChange, even if some are invalid\\n         * without reverting the entire transaction */\\n        try ILeveragedPool(_pool).poolUpkeep(lastExecutionPrice, latestPrice) {\\n            executionPrice[_pool] = latestPrice;\\n            // If poolUpkeep is successful, refund the keeper for their gas costs\\n            emit UpkeepSuccessful(_pool, data, lastExecutionPrice, latestPrice);\\n        } catch Error(string memory reason) {\\n            // If poolUpkeep fails for any other reason, emit event\\n            emit PoolUpkeepError(_pool, reason);\\n        }\\n\\n        uint256 gasSpent = startGas - gasleft();\\n        uint256 reward = IKeeperRewards(keeperRewards).payKeeper(\\n            msg.sender,\\n            _pool,\\n            gasPrice,\\n            gasSpent,\\n            savedPreviousUpdatedTimestamp,\\n            updateInterval\\n        );\\n        // Emit events depending on whether or not the reward was actually paid\\n        if (reward > 0) {\\n            emit KeeperPaid(_pool, msg.sender, reward);\\n        } else {\\n            emit KeeperPaymentError(_pool, msg.sender, reward);\\n        }\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on multiple pools\\n     * @param pools Addresses of each pool to upkeep\\n     * @dev Iterates over the provided array\\n     * @dev Essentially wraps calls to `performUpkeepSinglePool`\\n     */\\n    function performUpkeepMultiplePools(address[] calldata pools) external override {\\n        uint256 poolsLength = pools.length;\\n        for (uint256 i = 0; i < poolsLength; i = unchecked_inc(i)) {\\n            performUpkeepSinglePool(pools[i]);\\n        }\\n    }\\n\\n    /**\\n     * @notice Changes the KeeperRewards contract, used for calculating and executing rewards for calls to upkeep functions\\n     * @param _keeperRewards The new KeeperRewards contract\\n     * @dev Only callable by the contract owner\\n     * @dev emits KeeperRewardsSet when the addresss is successfuly changed\\n     */\\n    function setKeeperRewards(address _keeperRewards) external override onlyOwner {\\n        require(_keeperRewards != address(0), \\\"KeeperRewards cannot be 0 address\\\");\\n        address oldKeeperRewards = keeperRewards;\\n        keeperRewards = _keeperRewards;\\n        emit KeeperRewardsSet(oldKeeperRewards, _keeperRewards);\\n    }\\n\\n    /**\\n     * @notice Called by keepers to perform an update on multiple pools\\n     * @param pools A tightly packed bytes array of LeveragedPool addresses to be upkept\\n     *  __________________________________________________\\n     * |   20 bytes       20 bytes       20 bytes     ... |\\n     * | pool address | pool address | pool address | ... |\\n     *  \\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\u203e\\n     * @dev Arguments can be encoded with `L2Encoder.encodeAddressArray`\\n     * @dev Will revert if the bytes array is a correct length (some multiple of 20 bytes)\\n     */\\n    function performUpkeepMultiplePoolsPacked(bytes calldata pools) external override {\\n        require(pools.length % CalldataLogic.ADDRESS_LENGTH == 0, \\\"Data must only include addresses\\\");\\n        uint256 numPools = pools.length / CalldataLogic.ADDRESS_LENGTH;\\n        uint256 offset;\\n        assembly {\\n            offset := pools.offset\\n        }\\n        for (uint256 i = 0; i < numPools; ) {\\n            performUpkeepSinglePool(CalldataLogic.getAddressAtOffset(offset));\\n            unchecked {\\n                offset += CalldataLogic.ADDRESS_LENGTH;\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Sets the gas price to be used in compensating keepers for successful upkeep\\n     * @param _price Price (in ETH) per unit gas\\n     * @dev Only callable by the owner\\n     * @dev This function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`\\n     * @dev Emits a `GasPriceChanged` event on success\\n     */\\n    function setGasPrice(uint256 _price) external override onlyOwner {\\n        gasPrice = _price;\\n        emit GasPriceChanged(_price);\\n    }\\n\\n    function unchecked_inc(uint256 i) private pure returns (uint256) {\\n        unchecked {\\n            return ++i;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5f7a2801a83b0e3a831a72e6d63bfdb5a394cdcb979bbca16d061735268eada8\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IERC20DecimalsWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The decimals interface for extending the ERC20 interface\\ninterface IERC20DecimalsWrapper {\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x4f82de779074fc6767f24ff3f64ed1cd372277c05baca50ecd6f0d147a895f24\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IKeeperRewards.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\ninterface IKeeperRewards {\\n    /**\\n     * @notice Creates a notification of a failed pool update\\n     * @param pool The pool that failed to update\\n     * @param reason The reason for the error\\n     */\\n    event PoolUpkeepError(address indexed pool, string reason);\\n\\n    function payKeeper(\\n        address _keeper,\\n        address _pool,\\n        uint256 _gasPrice,\\n        uint256 _gasSpent,\\n        uint256 _savedPreviousUpdatedTimestamp,\\n        uint256 _updateInterval\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0x1e7f26cb2b5d7767f90e7d7739b9e183477419824c92bf2e4b8f7d065f30eaef\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/ILeveragedPool.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The pool controller contract interface\\ninterface ILeveragedPool {\\n    // Initialisation parameters for new market\\n    struct Initialization {\\n        address _owner; // Owner of the contract\\n        address _keeper; // The address of the PoolKeeper contract\\n        address _oracleWrapper; // The oracle wrapper for the derivative price feed\\n        address _settlementEthOracle; // The oracle wrapper for the SettlementToken/ETH price feed\\n        address _longToken; // Address of the long pool token\\n        address _shortToken; // Address of the short pool token\\n        address _poolCommitter; // Address of the PoolCommitter contract\\n        address _invariantCheck; // Address of the InvariantCheck contract\\n        string _poolName; // The pool identification name\\n        uint32 _frontRunningInterval; // The minimum number of seconds that must elapse before a commit is forced to wait until the next interval\\n        uint32 _updateInterval; // The minimum number of seconds that must elapse before a commit can be executed\\n        uint16 _leverageAmount; // The amount of exposure to price movements for the pool\\n        uint256 _fee; // The fund movement fee. This amount is extracted from the deposited asset with every update and sent to the fee address. Given as the decimal * 10 ^ 18. For example, 60% fee is 0.6 * 10 ^ 18\\n        address _feeAddress; // The address that the fund movement fee is sent to\\n        address _secondaryFeeAddress; // The address of fee recieved by third party deployers\\n        address _settlementToken; //  The digital asset that the pool accepts. Must have a decimals() function\\n        uint256 _secondaryFeeSplitPercent; // Percent of fees that go to secondary fee address if it exists\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when the pool is setup and ready for use\\n     * @param longToken The address of the LONG pair token\\n     * @param shortToken The address of the SHORT pair token\\n     * @param settlementToken The address of the digital asset that the pool accepts\\n     * @param poolName The identification name of the pool\\n     */\\n    event PoolInitialized(\\n        address indexed longToken,\\n        address indexed shortToken,\\n        address settlementToken,\\n        string poolName\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool is rebalanced\\n     * @param shortBalanceChange The change of funds in the short side\\n     * @param longBalanceChange The change of funds in the long side\\n     * @param shortFeeAmount Proportional fee taken from short side\\n     * @param longFeeAmount Proportional fee taken from long side\\n     */\\n    event PoolRebalance(\\n        int256 shortBalanceChange,\\n        int256 longBalanceChange,\\n        uint256 shortFeeAmount,\\n        uint256 longFeeAmount\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool's price execution fails\\n     * @param startPrice Price prior to price change execution\\n     * @param endPrice Price during price change execution\\n     */\\n    event PriceChangeError(int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Represents change in fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event FeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in secondary fee receiver's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event SecondaryFeeAddressUpdated(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Represents change in keeper's address\\n     * @param oldAddress Previous address\\n     * @param newAddress Address after change\\n     */\\n    event KeeperAddressChanged(address indexed oldAddress, address indexed newAddress);\\n\\n    /**\\n     * @notice Indicates a payment of fees to the secondary fee address\\n     * @param secondaryFeeAddress The address that got fees paid to it\\n     * @param amount Amount of settlement token paid\\n     */\\n    event SecondaryFeesPaid(address indexed secondaryFeeAddress, uint256 amount);\\n\\n    /**\\n     * @notice Indicates a payment of fees to the primary fee address\\n     * @param feeAddress The address that got fees paid to it\\n     * @param amount Amount of settlement token paid\\n     */\\n    event PrimaryFeesPaid(address indexed feeAddress, uint256 amount);\\n\\n    /**\\n     * @notice Indicates settlement assets have been withdrawn from the system\\n     * @param to Receipient\\n     * @param quantity Quantity of settlement tokens withdrawn\\n     */\\n    event SettlementWithdrawn(address indexed to, uint256 indexed quantity);\\n\\n    /**\\n     * @notice Indicates that the balance of pool tokens on issue for the pool\\n     *          changed\\n     * @param long New quantity of long pool tokens\\n     * @param short New quantity of short pool tokens\\n     */\\n    event PoolBalancesChanged(uint256 indexed long, uint256 indexed short);\\n\\n    function leverageAmount() external view returns (bytes16);\\n\\n    function poolCommitter() external view returns (address);\\n\\n    function settlementToken() external view returns (address);\\n\\n    function primaryFees() external view returns (uint256);\\n\\n    function secondaryFees() external view returns (uint256);\\n\\n    function oracleWrapper() external view returns (address);\\n\\n    function lastPriceTimestamp() external view returns (uint256);\\n\\n    function poolName() external view returns (string calldata);\\n\\n    function updateInterval() external view returns (uint32);\\n\\n    function shortBalance() external view returns (uint256);\\n\\n    function longBalance() external view returns (uint256);\\n\\n    function frontRunningInterval() external view returns (uint32);\\n\\n    function poolTokens() external view returns (address[2] memory);\\n\\n    function settlementEthOracle() external view returns (address);\\n\\n    // #### Functions\\n    /**\\n     * @notice Configures the pool on deployment. The pools are EIP 1167 clones.\\n     * @dev This should only be able to be run once to prevent abuse of the pool. Use of Openzeppelin Initializable or similar is recommended\\n     * @param initialization The struct Initialization containing initialization data\\n     */\\n    function initialize(Initialization calldata initialization) external;\\n\\n    function poolUpkeep(int256 _oldPrice, int256 _newPrice) external;\\n\\n    function settlementTokenTransferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function payKeeperFromBalances(address to, uint256 amount) external returns (bool);\\n\\n    function settlementTokenTransfer(address to, uint256 amount) external;\\n\\n    function claimPrimaryFees() external;\\n\\n    function claimSecondaryFees() external;\\n\\n    /**\\n     * @notice Transfer pool tokens from pool to user\\n     * @param isLongToken True if transferring long pool token; False if transferring short pool token\\n     * @param to Address of account to transfer to\\n     * @param amount Amount of pool tokens being transferred\\n     * @dev Only callable by the associated `PoolCommitter` contract\\n     * @dev Only callable when the market is *not* paused\\n     */\\n    function poolTokenTransfer(\\n        bool isLongToken,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function setNewPoolBalances(uint256 _longBalance, uint256 _shortBalance) external;\\n\\n    /**\\n     * @return _latestPrice The oracle price\\n     * @return _data The oracleWrapper's metadata. Implementations can choose what data to return here\\n     * @return _lastPriceTimestamp The timestamp of the last upkeep\\n     * @return _updateInterval The update frequency for this pool\\n     * @dev To save gas so PoolKeeper does not have to make three external calls\\n     */\\n    function getUpkeepInformation()\\n        external\\n        view\\n        returns (\\n            int256 _latestPrice,\\n            bytes memory _data,\\n            uint256 _lastPriceTimestamp,\\n            uint256 _updateInterval\\n        );\\n\\n    function getOraclePrice() external view returns (int256);\\n\\n    function intervalPassed() external view returns (bool);\\n\\n    function balances() external view returns (uint256 _shortBalance, uint256 _longBalance);\\n\\n    function setKeeper(address _keeper) external;\\n\\n    function updateFeeAddress(address account) external;\\n\\n    function updateSecondaryFeeAddress(address account) external;\\n\\n    function burnTokens(\\n        uint256 tokenType,\\n        uint256 amount,\\n        address burner\\n    ) external;\\n}\\n\",\"keccak256\":\"0x28dbf3ed3ba740e91b3fea40648882edee30eaf5094aec0d90be8853336ce97d\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IOracleWrapper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The oracle wrapper contract interface\\ninterface IOracleWrapper {\\n    function oracle() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function deployer() external view returns (address);\\n\\n    // #### Functions\\n\\n    /**\\n     * @notice Returns the current price for the asset in question\\n     * @return The latest price\\n     */\\n    function getPrice() external view returns (int256);\\n\\n    /**\\n     * @return _price The latest round data price\\n     * @return _data The metadata. Implementations can choose what data to return here\\n     */\\n    function getPriceAndMetadata() external view returns (int256 _price, bytes memory _data);\\n\\n    /**\\n     * @notice Converts from a WAD to normal value\\n     * @return Converted non-WAD value\\n     */\\n    function fromWad(int256 wad) external view returns (int256);\\n\\n    /**\\n     * @notice Updates the underlying oracle state and returns the new price\\n     * @dev Spot oracles must implement but it will be a no-op\\n     */\\n    function poll() external returns (int256);\\n}\\n\",\"keccak256\":\"0x33c55def28bddae3104b69d32cb0b13dad2ef95f59268fa8ec29575c965a5d43\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    function isMint(CommitType t) external pure returns (bool);\\n\\n    function isBurn(CommitType t) external pure returns (bool);\\n\\n    function isLong(CommitType t) external pure returns (bool);\\n\\n    function isShort(CommitType t) external pure returns (bool);\\n\\n    // Pool balances and supplies\\n    struct BalancesAndSupplies {\\n        uint256 newShortBalance;\\n        uint256 newLongBalance;\\n        uint256 longMintPoolTokens;\\n        uint256 shortMintPoolTokens;\\n        uint256 longBurnInstantMintSettlement;\\n        uint256 shortBurnInstantMintSettlement;\\n        uint256 totalLongBurnPoolTokens;\\n        uint256 totalShortBurnPoolTokens;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n    }\\n\\n    // User updated aggregate balance\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _longSettlementFee;\\n        uint256 _shortSettlementFee;\\n        uint8 _maxIterations;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 updateIntervalId;\\n    }\\n\\n    // Track the relevant data when executing a range of update interval's commitments (stack too deep)\\n    struct CommitmentExecutionTracking {\\n        uint256 longTotalSupply;\\n        uint256 shortTotalSupply;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n        uint256 _updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param fromAggregateBalance whether or not to commit from aggregate (unclaimed) balance\\n     * @param payForClaim whether or not to request this commit be claimed automatically\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bool fromAggregateBalance,\\n        bool payForClaim,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the PoolCommitter's leveragedPool address has been updated.\\n     * @param newPool the address of the new leveraged pool\\n     */\\n    event PoolChanged(address indexed newPool);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /*\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    /**\\n     * @notice Creates a notification when the feeController is updated\\n     */\\n    event FeeControllerSet(address indexed _feeController);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _autoClaim,\\n        address _factoryOwner,\\n        address _feeController,\\n        address _invariantCheck,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(bytes32 args) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function pendingMintSettlementAmount() external view returns (uint256);\\n\\n    function pendingShortBurnPoolTokens() external view returns (uint256);\\n\\n    function pendingLongBurnPoolTokens() external view returns (uint256);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments(\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setPool(address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function setFeeController(address _feeController) external;\\n}\\n\",\"keccak256\":\"0x3ca6c1ecf4adddd432451c3d8f3d41ffb19c2c7eff6d6a66b84b281a42235d52\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolFactory.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The contract factory for the keeper and pool contracts. Utilizes minimal clones to keep gas costs low\\ninterface IPoolFactory {\\n    struct PoolDeployment {\\n        string poolName; // The name to identify a pool by\\n        uint32 frontRunningInterval; // The minimum number of seconds that must elapse before a commit can be executed. Must be smaller than or equal to the update interval to prevent deadlock\\n        uint32 updateInterval; // The minimum number of seconds that must elapse before a price change\\n        uint16 leverageAmount; // The amount of exposure to price movements for the pool\\n        address settlementToken; // The digital asset that the pool accepts\\n        address oracleWrapper; // The IOracleWrapper implementation for fetching price feed data\\n        address settlementEthOracle; // The oracle to fetch the price of Ether in terms of the settlement token\\n        address feeController;\\n        // The fee taken for each mint and burn. Fee value as a decimal multiplied by 10^18. For example, 50% is represented as 0.5 * 10^18\\n        uint256 mintingFee; // The fee amount for mints\\n        uint256 changeInterval; // The interval at which the mintingFee in a market either increases or decreases, as per the logic in `PoolCommitter::updateMintingFee`\\n        uint256 burningFee; // The fee amount for burns\\n    }\\n\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is deployed\\n     * @param pool Address of the new pool\\n     * @param ticker Ticker of the new pool\\n     */\\n    event DeployPool(address indexed pool, address poolCommitter, string ticker);\\n\\n    /**\\n     * @notice Indicates that the InvariantCheck contract has changed\\n     * @param invariantCheck New InvariantCheck contract\\n     */\\n    event InvariantCheckChanged(address indexed invariantCheck);\\n\\n    /**\\n     * @notice Creates a notification when a PoolCommitter is deployed\\n     * @param poolCommitterAddress Address of new PoolCommitter\\n     * @param settlementToken Address of new settlementToken\\n     * @param pool Address of the pool associated with this PoolCommitter\\n     * @param changeInterval The amount that the `mintingFee` will change each update interval, based on `updateMintingFee`, given as a decimal * 10 ^ 18 (same format as `_mintingFee`)\\n     * @param feeController The address that has control over fee parameters\\n     */\\n    event DeployCommitter(\\n        address poolCommitterAddress,\\n        address settlementToken,\\n        address pool,\\n        uint256 changeInterval,\\n        address feeController\\n    );\\n\\n    /**\\n     * @notice Creates a notification when the pool keeper changes\\n     * @param _poolKeeper Address of the new pool keeper\\n     */\\n    event PoolKeeperChanged(address _poolKeeper);\\n\\n    /**\\n     * @notice Indicates that the maximum allowed leverage has changed\\n     * @param leverage New maximum allowed leverage value\\n     */\\n    event MaxLeverageChanged(uint256 indexed leverage);\\n\\n    /**\\n     * @notice Indicates that the receipient of fees has changed\\n     * @param receiver Address of the new receipient of fees\\n     */\\n    event FeeReceiverChanged(address indexed receiver);\\n\\n    /**\\n     * @notice Indicates that the receipient of fees has changed\\n     * @param fee Address of the new receipient of fees\\n     */\\n    event SecondaryFeeSplitChanged(uint256 indexed fee);\\n\\n    /**\\n     * @notice Indicates that the trading fee has changed\\n     * @param fee New trading fee\\n     */\\n    event FeeChanged(uint256 indexed fee);\\n\\n    /**\\n     * @notice Indicates that the AutoClaim contract has changed\\n     * @param autoClaim New AutoClaim contract\\n     */\\n    event AutoClaimChanged(address indexed autoClaim);\\n\\n    /**\\n     * @notice Indicates that the minting and burning fees have changed\\n     * @param mint Minting fee\\n     * @param burn Burning fee\\n     */\\n    event MintAndBurnFeesChanged(uint256 indexed mint, uint256 indexed burn);\\n\\n    /**\\n     * @notice Indicates that the deployment fee has changed\\n     * @param fee New deployment fee\\n     */\\n    event DeploymentFeeChanged(address _token, uint256 fee, address _receiver);\\n\\n    // #### Getters for Globals\\n    function pools(uint256 id) external view returns (address);\\n\\n    function numPools() external view returns (uint256);\\n\\n    function isValidPool(address _pool) external view returns (bool);\\n\\n    function isValidPoolCommitter(address _poolCommitter) external view returns (bool);\\n\\n    function getPoolKeeper() external view returns (address);\\n\\n    // #### Functions\\n    function deployPool(PoolDeployment calldata deploymentParameters) external returns (address);\\n\\n    function setPoolKeeper(address _poolKeeper) external;\\n\\n    function setAutoClaim(address _autoClaim) external;\\n\\n    function setInvariantCheck(address _invariantCheck) external;\\n\\n    function setFeeReceiver(address _feeReceiver) external;\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setDeploymentFee(\\n        address _token,\\n        uint256 _fee,\\n        address _receiver\\n    ) external;\\n\\n    function setSecondaryFeeSplitPercent(uint256 newFeePercent) external;\\n}\\n\",\"keccak256\":\"0x7e090f7c77fd85ec845de116de57ca058754bc3b7d65f6de9867c85223d1e59d\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolKeeper.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The manager contract interface for multiple markets and the pools in them\\ninterface IPoolKeeper {\\n    // #### Events\\n    /**\\n     * @notice Creates a notification when a pool is created\\n     * @param poolAddress The pool address of the newly created pool\\n     * @param firstPrice The price of the market oracle when the pool was created\\n     */\\n    event PoolAdded(address indexed poolAddress, int256 indexed firstPrice);\\n\\n    /**\\n     * @notice Creates a notification when a call to LeveragedPool:poolUpkeep is successful\\n     * @param pool The pool address being upkept\\n     * @param data Extra data about the price fetch. This could be roundID in the case of Chainlink Oracles\\n     * @param startPrice The previous price of the pool\\n     * @param endPrice The new price of the pool\\n     */\\n    event UpkeepSuccessful(address indexed pool, bytes data, int256 indexed startPrice, int256 indexed endPrice);\\n\\n    /**\\n     * @notice Creates a notification when a keeper is paid for doing upkeep for a pool\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param reward Keeper's reward (in settlement tokens)\\n     */\\n    event KeeperPaid(address indexed _pool, address indexed keeper, uint256 reward);\\n\\n    /**\\n     * @notice Creates a notification when a keeper's payment for upkeeping a pool failed\\n     * @param _pool Address of pool being upkept\\n     * @param keeper Keeper to be rewarded for upkeeping\\n     * @param expectedReward Keeper's expected reward (in settlement tokens); not actually transferred\\n     */\\n    event KeeperPaymentError(address indexed _pool, address indexed keeper, uint256 expectedReward);\\n\\n    /**\\n     * @notice Creates a notification of a failed pool update\\n     * @param pool The pool that failed to update\\n     * @param reason The reason for the error\\n     */\\n    event PoolUpkeepError(address indexed pool, string reason);\\n\\n    /**\\n     * @notice Indicates that the factory address has changed\\n     * @param factory Address of the new factory\\n     */\\n    event FactoryChanged(address indexed factory);\\n\\n    /**\\n     * @notice Indicates that the KeeperRewards contract has\\n     * @param oldKeeperRewards The previous KeeperRewards contract\\n     * @param newKeeperRewards The new KeeperRewards contract\\n     */\\n    event KeeperRewardsSet(address indexed oldKeeperRewards, address indexed newKeeperRewards);\\n\\n    /**\\n     * @notice Indicates that the gas price for keeper rewards changed\\n     * @param price New gas price\\n     */\\n    event GasPriceChanged(uint256 indexed price);\\n\\n    // #### Variables\\n\\n    function keeperRewards() external returns (address);\\n\\n    // #### Functions\\n    function newPool(address _poolAddress) external;\\n\\n    function isUpkeepRequiredSinglePool(address pool) external view returns (bool);\\n\\n    function checkUpkeepMultiplePools(address[] calldata pools) external view returns (bool);\\n\\n    function performUpkeepSinglePool(address pool) external;\\n\\n    function performUpkeepMultiplePools(address[] calldata pools) external;\\n\\n    function setKeeperRewards(address _keeperRewards) external;\\n\\n    function setGasPrice(uint256 _price) external;\\n\\n    function performUpkeepMultiplePoolsPacked(bytes calldata pools) external;\\n}\\n\",\"keccak256\":\"0x74875932228c36c1d54d698f6258f3285ebb6e148d043e72bf7466720926e650\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/libraries/CalldataLogic.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\n\\n/// @title CalldataLogic library\\n/// @notice Library to decode calldata, used to optimize calldata size in PerpetualPools for L2 transaction cost reduction\\nlibrary CalldataLogic {\\n    /*\\n     * Calldata when parameter is a tightly packed byte array looks like this:\\n     * -----------------------------------------------------------------------------------------------------\\n     * | function signature | offset of byte array | length of byte array |           bytes array           |\\n     * |      4 bytes       |       32 bytes       |       32 bytes       |  20 * number_of_addresses bytes |\\n     * -----------------------------------------------------------------------------------------------------\\n     *\\n     * If there are two bytes arrays, then it looks like\\n     * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n     * | function signature | offset of 1st byte array | offset of 2nd byte array | length of 1st byte array |        1st bytes array          | length of 2nd byte array |        2nd bytes array          |\\n     * |      4 bytes       |        32 bytes          |        32 bytes          |         32 bytes         |  20 * number_of_addresses bytes |         32 bytes         |  20 * number_of_addresses bytes |\\n     * ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n     * and so on...\\n     * Note that the offset indicates where the length is indicated, and the actual array itself starts 32 bytes after that\\n     */\\n    // Length of address = 20\\n    uint16 internal constant ADDRESS_LENGTH = 20;\\n\\n    function getAddressAtOffset(uint256 offset) internal pure returns (address) {\\n        bytes20 addressAtOffset;\\n        assembly {\\n            addressAtOffset := calldataload(offset)\\n        }\\n        return (address(addressAtOffset));\\n    }\\n\\n    /**\\n     * @notice decodes compressed commit params to standard params\\n     * @param args The packed commit args\\n     * @return The amount of settlement or pool tokens to commit\\n     * @return The CommitType\\n     * @return Whether to make the commitment from user's aggregate balance\\n     * @return Whether to pay for an autoclaim or not\\n     */\\n    function decodeCommitParams(bytes32 args)\\n        internal\\n        pure\\n        returns (\\n            uint256,\\n            IPoolCommitter.CommitType,\\n            bool,\\n            bool\\n        )\\n    {\\n        uint256 amount;\\n        IPoolCommitter.CommitType commitType;\\n        bool fromAggregateBalance;\\n        bool payForClaim;\\n\\n        // `amount` is implicitly capped at 128 bits.\\n        assembly {\\n            amount := and(args, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n            commitType := and(shr(128, args), 0xFF)\\n            fromAggregateBalance := and(shr(136, args), 0xFF)\\n            payForClaim := and(shr(144, args), 0xFF)\\n        }\\n        return (amount, commitType, fromAggregateBalance, payForClaim);\\n    }\\n}\\n\",\"keccak256\":\"0xa9add143cbf68a361ae92001c0aaafffd1041fd78d6363e2c77acc3a8d2432ae\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x60a06040526402540be40060035534801561001957600080fd5b506040516113bc3803806113bc833981016040819052610038916100fc565b610041336100ac565b6001600160a01b03811661009b5760405162461bcd60e51b815260206004820152601660248201527f466163746f72792063616e6e6f74206265206e756c6c00000000000000000000604482015260640160405180910390fd5b6001600160a01b031660805261012c565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006020828403121561010e57600080fd5b81516001600160a01b038116811461012557600080fd5b9392505050565b608051611267610155600039600081816101b90152818161031b015261042501526112676000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c8063bf1fe42011610097578063e98ccdc411610066578063e98ccdc41461021c578063f2fde38b1461022f578063fcab9e9814610242578063fe173b971461025557600080fd5b8063bf1fe420146101a1578063c45a0155146101b4578063cdd9e137146101db578063ce1dcdfc1461020957600080fd5b8063715018a6116100d3578063715018a61461014a578063857ad312146101525780638da5cb5b1461017d57806391a607821461018e57600080fd5b80632027574e146100fa578063332611111461010f5780633c5c7fb314610137575b600080fd5b61010d610108366004610dfe565b61025e565b005b61012261011d366004610e85565b6102f9565b60405190151581526020015b60405180910390f35b61010d610145366004610e85565b61041a565b61010d610682565b600254610165906001600160a01b031681565b6040516001600160a01b03909116815260200161012e565b6000546001600160a01b0316610165565b61010d61019c366004610e85565b6106b8565b61010d6101af366004610ea9565b610b3c565b6101657f000000000000000000000000000000000000000000000000000000000000000081565b6101fb6101e9366004610e85565b60016020526000908152604090205481565b60405190815260200161012e565b610122610217366004610ec2565b610b99565b61010d61022a366004610e85565b610bf3565b61010d61023d366004610e85565b610ccf565b61010d610250366004610ec2565b610d6a565b6101fb60035481565b610269601482610f3b565b156102bb5760405162461bcd60e51b815260206004820181905260248201527f44617461206d757374206f6e6c7920696e636c7564652061646472657373657360448201526064015b60405180910390fd5b60006102c8601483610f4f565b90508260005b828110156102f2576102e3823560601c6106b8565b601491909101906001016102ce565b5050505050565b604051635ab78ee160e01b81526001600160a01b0382811660048301526000917f000000000000000000000000000000000000000000000000000000000000000090911690635ab78ee19060240160206040518083038186803b15801561035f57600080fd5b505afa158015610373573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103979190610f63565b6103a357506000919050565b816001600160a01b0316637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b1580156103dc57600080fd5b505afa1580156103f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104149190610f63565b92915050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146104875760405162461bcd60e51b815260206004820152601260248201527143616c6c6572206e6f7420666163746f727960701b60448201526064016102b2565b806001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104c057600080fd5b505afa1580156104d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f89190610f85565b6001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561053257600080fd5b505af1158015610546573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056a9190610fa2565b506000816001600160a01b031663796da7af6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105a657600080fd5b505afa1580156105ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105de9190610fa2565b9050600081136106305760405162461bcd60e51b815260206004820152601b60248201527f4669727374207072696365206973206e6f6e2d706f736974697665000000000060448201526064016102b2565b60405181906001600160a01b038416907fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b90600090a36001600160a01b03909116600090815260016020526040902055565b6000546001600160a01b031633146106ac5760405162461bcd60e51b81526004016102b290610fbb565b6106b66000610dae565b565b60005a90506106c6826102f9565b6106ce575050565b6000826001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561070957600080fd5b505afa15801561071d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107419190610f85565b9050806001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561077e57600080fd5b505af19250505080156107ae575060408051601f3d908101601f191682019092526107ab91810190610fa2565b60015b61082d576107ba610ff0565b806308c379a0141561082157506107cf61104f565b806107da5750610823565b836001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516108139190611131565b60405180910390a25061082f565b505b3d6000803e3d6000fd5b505b600080600080866001600160a01b03166304883c276040518163ffffffff1660e01b815260040160006040518083038186803b15801561086e57600080fd5b505afa158015610882573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108aa9190810190611144565b6001600160a01b038b16600081815260016020526040908190205490516303d8ce9d60e61b815260048101829052602481018790529599509397509195509350909163f633a74090604401600060405180830381600087803b15801561090f57600080fd5b505af1925050508015610920575060015b6109935761092c610ff0565b806308c379a01415610821575061094161104f565b8061094c5750610823565b886001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516109859190611131565b60405180910390a2506109eb565b6001600160a01b0388166000818152600160205260409081902087905551869183917f0aa8d2838ad6d4e2a5d7ca0826dfdbc36d922adf8fe5c6d25aee2724b07de074906109e2908990611131565b60405180910390a45b60005a6109f890896111f6565b60025460035460405163348c2b1f60e01b81523360048201526001600160a01b038d811660248301526044820192909252606481018490526084810188905260a4810187905292935060009291169063348c2b1f9060c401602060405180830381600087803b158015610a6a57600080fd5b505af1158015610a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa29190610fa2565b90508015610aef5760405181815233906001600160a01b038c16907ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b0829060200160405180910390a3610b30565b60405181815233906001600160a01b038c16907f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde056979060200160405180910390a35b50505050505050505050565b6000546001600160a01b03163314610b665760405162461bcd60e51b81526004016102b290610fbb565b600381905560405181907f52264b89e0fceafb26e79fd49ef8a366eb6297483bf4035b027f0c99a7ad512e90600090a250565b600081815b81811015610be857610bd0858583818110610bbb57610bbb61121b565b905060200201602081019061011d9190610e85565b15610be057600192505050610414565b600101610b9e565b506000949350505050565b6000546001600160a01b03163314610c1d5760405162461bcd60e51b81526004016102b290610fbb565b6001600160a01b038116610c7d5760405162461bcd60e51b815260206004820152602160248201527f4b6565706572526577617264732063616e6e6f742062652030206164647265736044820152607360f81b60648201526084016102b2565b600280546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fed60217a0f5e211a1105c7e6fdc9df5753b136c553ae2974a15e8be0cc02ac7390600090a35050565b6000546001600160a01b03163314610cf95760405162461bcd60e51b81526004016102b290610fbb565b6001600160a01b038116610d5e5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016102b2565b610d6781610dae565b50565b8060005b81811015610da857610da0848483818110610d8b57610d8b61121b565b905060200201602081019061019c9190610e85565b600101610d6e565b50505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008060208385031215610e1157600080fd5b823567ffffffffffffffff80821115610e2957600080fd5b818501915085601f830112610e3d57600080fd5b813581811115610e4c57600080fd5b866020828501011115610e5e57600080fd5b60209290920196919550909350505050565b6001600160a01b0381168114610d6757600080fd5b600060208284031215610e9757600080fd5b8135610ea281610e70565b9392505050565b600060208284031215610ebb57600080fd5b5035919050565b60008060208385031215610ed557600080fd5b823567ffffffffffffffff80821115610eed57600080fd5b818501915085601f830112610f0157600080fd5b813581811115610f1057600080fd5b8660208260051b8501011115610e5e57600080fd5b634e487b7160e01b600052601260045260246000fd5b600082610f4a57610f4a610f25565b500690565b600082610f5e57610f5e610f25565b500490565b600060208284031215610f7557600080fd5b81518015158114610ea257600080fd5b600060208284031215610f9757600080fd5b8151610ea281610e70565b600060208284031215610fb457600080fd5b5051919050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600060033d11156110095760046000803e5060005160e01c5b90565b634e487b7160e01b600052604160045260246000fd5b601f8201601f1916810167ffffffffffffffff811182821017156110485761104861100c565b6040525050565b600060443d101561105d5790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561108d57505050505090565b82850191508151818111156110a55750505050505090565b843d87010160208285010111156110bf5750505050505090565b6110ce60208286010187611022565b509095945050505050565b60005b838110156110f45781810151838201526020016110dc565b83811115610da85750506000910152565b6000815180845261111d8160208601602086016110d9565b601f01601f19169290920160200192915050565b602081526000610ea26020830184611105565b6000806000806080858703121561115a57600080fd5b84519350602085015167ffffffffffffffff8082111561117957600080fd5b818701915087601f83011261118d57600080fd5b81518181111561119f5761119f61100c565b60405191506111b8601f8201601f191660200183611022565b8082528860208285010111156111cd57600080fd5b6111de8160208401602086016110d9565b50604087015160609097015195989097509350505050565b60008282101561121657634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052603260045260246000fdfea26469706673582212206bbbe69a6a6eb3d4e0a63524a4728f7eb589c8bac411ca9cdf33717a2091e11764736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100f55760003560e01c8063bf1fe42011610097578063e98ccdc411610066578063e98ccdc41461021c578063f2fde38b1461022f578063fcab9e9814610242578063fe173b971461025557600080fd5b8063bf1fe420146101a1578063c45a0155146101b4578063cdd9e137146101db578063ce1dcdfc1461020957600080fd5b8063715018a6116100d3578063715018a61461014a578063857ad312146101525780638da5cb5b1461017d57806391a607821461018e57600080fd5b80632027574e146100fa578063332611111461010f5780633c5c7fb314610137575b600080fd5b61010d610108366004610dfe565b61025e565b005b61012261011d366004610e85565b6102f9565b60405190151581526020015b60405180910390f35b61010d610145366004610e85565b61041a565b61010d610682565b600254610165906001600160a01b031681565b6040516001600160a01b03909116815260200161012e565b6000546001600160a01b0316610165565b61010d61019c366004610e85565b6106b8565b61010d6101af366004610ea9565b610b3c565b6101657f000000000000000000000000000000000000000000000000000000000000000081565b6101fb6101e9366004610e85565b60016020526000908152604090205481565b60405190815260200161012e565b610122610217366004610ec2565b610b99565b61010d61022a366004610e85565b610bf3565b61010d61023d366004610e85565b610ccf565b61010d610250366004610ec2565b610d6a565b6101fb60035481565b610269601482610f3b565b156102bb5760405162461bcd60e51b815260206004820181905260248201527f44617461206d757374206f6e6c7920696e636c7564652061646472657373657360448201526064015b60405180910390fd5b60006102c8601483610f4f565b90508260005b828110156102f2576102e3823560601c6106b8565b601491909101906001016102ce565b5050505050565b604051635ab78ee160e01b81526001600160a01b0382811660048301526000917f000000000000000000000000000000000000000000000000000000000000000090911690635ab78ee19060240160206040518083038186803b15801561035f57600080fd5b505afa158015610373573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103979190610f63565b6103a357506000919050565b816001600160a01b0316637bbf10336040518163ffffffff1660e01b815260040160206040518083038186803b1580156103dc57600080fd5b505afa1580156103f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104149190610f63565b92915050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146104875760405162461bcd60e51b815260206004820152601260248201527143616c6c6572206e6f7420666163746f727960701b60448201526064016102b2565b806001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156104c057600080fd5b505afa1580156104d4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104f89190610f85565b6001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561053257600080fd5b505af1158015610546573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061056a9190610fa2565b506000816001600160a01b031663796da7af6040518163ffffffff1660e01b815260040160206040518083038186803b1580156105a657600080fd5b505afa1580156105ba573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105de9190610fa2565b9050600081136106305760405162461bcd60e51b815260206004820152601b60248201527f4669727374207072696365206973206e6f6e2d706f736974697665000000000060448201526064016102b2565b60405181906001600160a01b038416907fe950cb32f7a787627d713d7365623fef2d762ef8fcf813b865a04350852deb9b90600090a36001600160a01b03909116600090815260016020526040902055565b6000546001600160a01b031633146106ac5760405162461bcd60e51b81526004016102b290610fbb565b6106b66000610dae565b565b60005a90506106c6826102f9565b6106ce575050565b6000826001600160a01b031663b9ed8abf6040518163ffffffff1660e01b815260040160206040518083038186803b15801561070957600080fd5b505afa15801561071d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107419190610f85565b9050806001600160a01b031663a11752796040518163ffffffff1660e01b8152600401602060405180830381600087803b15801561077e57600080fd5b505af19250505080156107ae575060408051601f3d908101601f191682019092526107ab91810190610fa2565b60015b61082d576107ba610ff0565b806308c379a0141561082157506107cf61104f565b806107da5750610823565b836001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516108139190611131565b60405180910390a25061082f565b505b3d6000803e3d6000fd5b505b600080600080866001600160a01b03166304883c276040518163ffffffff1660e01b815260040160006040518083038186803b15801561086e57600080fd5b505afa158015610882573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108aa9190810190611144565b6001600160a01b038b16600081815260016020526040908190205490516303d8ce9d60e61b815260048101829052602481018790529599509397509195509350909163f633a74090604401600060405180830381600087803b15801561090f57600080fd5b505af1925050508015610920575060015b6109935761092c610ff0565b806308c379a01415610821575061094161104f565b8061094c5750610823565b886001600160a01b03167f8a47468bf96478429d382ed6385d9c77fba8b89540cd88199b1b51d5723b11fa826040516109859190611131565b60405180910390a2506109eb565b6001600160a01b0388166000818152600160205260409081902087905551869183917f0aa8d2838ad6d4e2a5d7ca0826dfdbc36d922adf8fe5c6d25aee2724b07de074906109e2908990611131565b60405180910390a45b60005a6109f890896111f6565b60025460035460405163348c2b1f60e01b81523360048201526001600160a01b038d811660248301526044820192909252606481018490526084810188905260a4810187905292935060009291169063348c2b1f9060c401602060405180830381600087803b158015610a6a57600080fd5b505af1158015610a7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa29190610fa2565b90508015610aef5760405181815233906001600160a01b038c16907ff03012dd4aab142682aa01439f94e975e2ec77ef558352323bc05f382f74b0829060200160405180910390a3610b30565b60405181815233906001600160a01b038c16907f08b35d4c86707ba44cdcc5efaa79b8a307e6c7f789f1eb86ca1ff1e9bde056979060200160405180910390a35b50505050505050505050565b6000546001600160a01b03163314610b665760405162461bcd60e51b81526004016102b290610fbb565b600381905560405181907f52264b89e0fceafb26e79fd49ef8a366eb6297483bf4035b027f0c99a7ad512e90600090a250565b600081815b81811015610be857610bd0858583818110610bbb57610bbb61121b565b905060200201602081019061011d9190610e85565b15610be057600192505050610414565b600101610b9e565b506000949350505050565b6000546001600160a01b03163314610c1d5760405162461bcd60e51b81526004016102b290610fbb565b6001600160a01b038116610c7d5760405162461bcd60e51b815260206004820152602160248201527f4b6565706572526577617264732063616e6e6f742062652030206164647265736044820152607360f81b60648201526084016102b2565b600280546001600160a01b038381166001600160a01b0319831681179093556040519116919082907fed60217a0f5e211a1105c7e6fdc9df5753b136c553ae2974a15e8be0cc02ac7390600090a35050565b6000546001600160a01b03163314610cf95760405162461bcd60e51b81526004016102b290610fbb565b6001600160a01b038116610d5e5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b60648201526084016102b2565b610d6781610dae565b50565b8060005b81811015610da857610da0848483818110610d8b57610d8b61121b565b905060200201602081019061019c9190610e85565b600101610d6e565b50505050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008060208385031215610e1157600080fd5b823567ffffffffffffffff80821115610e2957600080fd5b818501915085601f830112610e3d57600080fd5b813581811115610e4c57600080fd5b866020828501011115610e5e57600080fd5b60209290920196919550909350505050565b6001600160a01b0381168114610d6757600080fd5b600060208284031215610e9757600080fd5b8135610ea281610e70565b9392505050565b600060208284031215610ebb57600080fd5b5035919050565b60008060208385031215610ed557600080fd5b823567ffffffffffffffff80821115610eed57600080fd5b818501915085601f830112610f0157600080fd5b813581811115610f1057600080fd5b8660208260051b8501011115610e5e57600080fd5b634e487b7160e01b600052601260045260246000fd5b600082610f4a57610f4a610f25565b500690565b600082610f5e57610f5e610f25565b500490565b600060208284031215610f7557600080fd5b81518015158114610ea257600080fd5b600060208284031215610f9757600080fd5b8151610ea281610e70565b600060208284031215610fb457600080fd5b5051919050565b6020808252818101527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604082015260600190565b600060033d11156110095760046000803e5060005160e01c5b90565b634e487b7160e01b600052604160045260246000fd5b601f8201601f1916810167ffffffffffffffff811182821017156110485761104861100c565b6040525050565b600060443d101561105d5790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561108d57505050505090565b82850191508151818111156110a55750505050505090565b843d87010160208285010111156110bf5750505050505090565b6110ce60208286010187611022565b509095945050505050565b60005b838110156110f45781810151838201526020016110dc565b83811115610da85750506000910152565b6000815180845261111d8160208601602086016110d9565b601f01601f19169290920160200192915050565b602081526000610ea26020830184611105565b6000806000806080858703121561115a57600080fd5b84519350602085015167ffffffffffffffff8082111561117957600080fd5b818701915087601f83011261118d57600080fd5b81518181111561119f5761119f61100c565b60405191506111b8601f8201601f191660200183611022565b8082528860208285010111156111cd57600080fd5b6111de8160208401602086016110d9565b50604087015160609097015195989097509350505050565b60008282101561121657634e487b7160e01b600052601160045260246000fd5b500390565b634e487b7160e01b600052603260045260246000fdfea26469706673582212206bbbe69a6a6eb3d4e0a63524a4728f7eb589c8bac411ca9cdf33717a2091e11764736f6c63430008090033",
  "libraries": {
    "PoolSwapLibrary": "0x4Ccb6F6a89E42E11e7Ff05eA83D755F59DD7eF9A"
  },
  "devdoc": {
    "details": "Currently, this contract estimates the best keeper rewards in a way that is best suited for Ethereum L1.It assumes an approximate block time of 13 seconds, and an Ethereum-like gas system.This code was also written with Arbitrum deployment in mind, meaning there exists no `block.basefee`, and no arbitrum gas price oracle.It has another large drawback in that it is not possible to calculate the cost of the current transaction Arbitrum, given that the cost is largely determined by L1 calldata cost.Because of this, the reward calculation is an rough \"good enough\" estimation.",
    "kind": "dev",
    "methods": {
      "checkUpkeepMultiplePools(address[])": {
        "details": "Iterates over the provided array of pool addresses",
        "params": {
          "_pools": "Array of pools to check"
        },
        "returns": {
          "_0": "Whether or not at least one pool needs upkeeping"
        }
      },
      "isUpkeepRequiredSinglePool(address)": {
        "params": {
          "_pool": "The address of the pool to upkeep"
        },
        "returns": {
          "_0": "Whether or not upkeep is needed for this single pool"
        }
      },
      "newPool(address)": {
        "details": "Only callable by the associated `PoolFactory` contract",
        "params": {
          "_poolAddress": "The address of the newly-created pools"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "performUpkeepMultiplePools(address[])": {
        "details": "Iterates over the provided arrayEssentially wraps calls to `performUpkeepSinglePool`",
        "params": {
          "pools": "Addresses of each pool to upkeep"
        }
      },
      "performUpkeepMultiplePoolsPacked(bytes)": {
        "details": "Arguments can be encoded with `L2Encoder.encodeAddressArray`Will revert if the bytes array is a correct length (some multiple of 20 bytes)",
        "params": {
          "pools": "A tightly packed bytes array of LeveragedPool addresses to be upkept  __________________________________________________ |   20 bytes       20 bytes       20 bytes     ... | | pool address | pool address | pool address | ... |  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾"
        }
      },
      "performUpkeepSinglePool(address)": {
        "details": "Tracks gas usage via `gasleft` accounting and uses this to inform          keeper paymentCatches any failure of the underlying `pool.poolUpkeep` callEmits a `KeeperPaid` event if the underlying call to `pool.payKeeperFromBalances` succeedsEmits a `KeeperPaymentError` event otherwise",
        "params": {
          "_pool": "Address of the pool to be upkept"
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "setGasPrice(uint256)": {
        "details": "Only callable by the ownerThis function is only necessary due to the L2 deployment of Pools -- in reality, it should be `BASEFEE`Emits a `GasPriceChanged` event on success",
        "params": {
          "_price": "Price (in ETH) per unit gas"
        }
      },
      "setKeeperRewards(address)": {
        "details": "Only callable by the contract owneremits KeeperRewardsSet when the addresss is successfuly changed",
        "params": {
          "_keeperRewards": "The new KeeperRewards contract"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      }
    },
    "title": "The manager contract for multiple markets and the pools in them",
    "version": 1
  },
  "userdoc": {
    "events": {
      "FactoryChanged(address)": {
        "notice": "Indicates that the factory address has changed"
      },
      "GasPriceChanged(uint256)": {
        "notice": "Indicates that the gas price for keeper rewards changed"
      },
      "KeeperPaid(address,address,uint256)": {
        "notice": "Creates a notification when a keeper is paid for doing upkeep for a pool"
      },
      "KeeperPaymentError(address,address,uint256)": {
        "notice": "Creates a notification when a keeper's payment for upkeeping a pool failed"
      },
      "KeeperRewardsSet(address,address)": {
        "notice": "Indicates that the KeeperRewards contract has"
      },
      "PoolAdded(address,int256)": {
        "notice": "Creates a notification when a pool is created"
      },
      "PoolUpkeepError(address,string)": {
        "notice": "Creates a notification of a failed pool update"
      },
      "UpkeepSuccessful(address,bytes,int256,int256)": {
        "notice": "Creates a notification when a call to LeveragedPool:poolUpkeep is successful"
      }
    },
    "kind": "user",
    "methods": {
      "checkUpkeepMultiplePools(address[])": {
        "notice": "Checks multiple pools if any of them need updating"
      },
      "executionPrice(address)": {
        "notice": "Format: Pool address => last executionPrice"
      },
      "isUpkeepRequiredSinglePool(address)": {
        "notice": "Check if upkeep is required"
      },
      "newPool(address)": {
        "notice": "When a pool is created, this function is called by the factory to initiate price trackings"
      },
      "performUpkeepMultiplePools(address[])": {
        "notice": "Called by keepers to perform an update on multiple pools"
      },
      "performUpkeepMultiplePoolsPacked(bytes)": {
        "notice": "Called by keepers to perform an update on multiple pools"
      },
      "performUpkeepSinglePool(address)": {
        "notice": "Called by keepers to perform an update on a single pool"
      },
      "setGasPrice(uint256)": {
        "notice": "Sets the gas price to be used in compensating keepers for successful upkeep"
      },
      "setKeeperRewards(address)": {
        "notice": "Changes the KeeperRewards contract, used for calculating and executing rewards for calls to upkeep functions"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 13823,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "executionPrice",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_int256)"
      },
      {
        "astId": 13829,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "keeperRewards",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      },
      {
        "astId": 13832,
        "contract": "contracts/implementation/PoolKeeper.sol:PoolKeeper",
        "label": "gasPrice",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_int256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => int256)",
        "numberOfBytes": "32",
        "value": "t_int256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}