{
  "address": "0x1b1c02682Bfd7AB30871bF292FC103AFCF04e586",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "args",
          "type": "address[]"
        }
      ],
      "name": "encodeAddressArray",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "enum IPoolCommitter.CommitType",
          "name": "commitType",
          "type": "uint8"
        },
        {
          "internalType": "bool",
          "name": "fromAggregateBalance",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "payForClaim",
          "type": "bool"
        }
      ],
      "name": "encodeCommitParams",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x22a3402a6d2b615cc95fb67032cb51277d24047d6c144fc39f46a42bfcf63f82",
  "receipt": {
    "to": null,
    "from": "0xd9c281C5501c3Fe2C95587A99C9d0a54dDa63712",
    "contractAddress": "0x1b1c02682Bfd7AB30871bF292FC103AFCF04e586",
    "transactionIndex": 1,
    "gasUsed": "638429",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x01e30957e704c7c4383089eed357ac01527e734796092f8b9e0f67831ea2afcb",
    "transactionHash": "0x22a3402a6d2b615cc95fb67032cb51277d24047d6c144fc39f46a42bfcf63f82",
    "logs": [],
    "blockNumber": 194564959,
    "cumulativeGasUsed": "638429",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "c531ec4aa0c6e728e159c9fdfa70dead",
  "metadata": "{\"compiler\":{\"version\":\"0.8.9+commit.e5eed63a\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"args\",\"type\":\"address[]\"}],\"name\":\"encodeAddressArray\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"enum IPoolCommitter.CommitType\",\"name\":\"commitType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"fromAggregateBalance\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"payForClaim\",\"type\":\"bool\"}],\"name\":\"encodeCommitParams\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"encodeAddressArray(address[])\":{\"params\":{\"args\":\"The array of LeveragedPool addresses to perform upkeep on\"},\"returns\":{\"_0\":\"compact bytes array of addresses\"}},\"encodeCommitParams(uint256,uint8,bool,bool)\":{\"params\":{\"amount\":\"Amount of settlement tokens you want to commit to minting; OR amount of pool               tokens you want to burn\",\"commitType\":\"Type of commit you're doing (Long vs Short, Mint vs Burn)\",\"fromAggregateBalance\":\"If minting, burning, or rebalancing into a delta neutral position,                             will tokens be taken from user's aggregate balance?\",\"payForClaim\":\"True if user wants to pay for the commit to be claimed\"},\"returns\":{\"_0\":\"compact representation of commit parameters\"}}},\"title\":\"L2Encoder\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"encodeAddressArray(address[])\":{\"notice\":\"Encodes an array of addresses to compact representation as a bytes array\"},\"encodeCommitParams(uint256,uint8,bool,bool)\":{\"notice\":\"Encodes commit parameters from standard input to compact representation of 1 bytes32\"}},\"notice\":\"Helper contract to encode calldata, used to optimize calldata size only indented to help generate calldata for uses/frontends.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/implementation/L2Encoder.sol\":\"L2Encoder\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128) {\\n        require(value >= type(int128).min && value <= type(int128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return int128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64) {\\n        require(value >= type(int64).min && value <= type(int64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return int64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32) {\\n        require(value >= type(int32).min && value <= type(int32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return int32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16) {\\n        require(value >= type(int16).min && value <= type(int16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return int16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8) {\\n        require(value >= type(int8).min && value <= type(int8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return int8(value);\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x08d867b4c0bb782b9135691fa732b6846e0f133006489c3aa505abd1f6de56cb\",\"license\":\"MIT\"},\"contracts/implementation/L2Encoder.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"../interfaces/IPoolCommitter.sol\\\";\\n\\n/**\\n * @title L2Encoder\\n * @notice Helper contract to encode calldata, used to optimize calldata size\\n * only indented to help generate calldata for uses/frontends.\\n */\\ncontract L2Encoder {\\n    using SafeCast for uint256;\\n\\n    /**\\n     * @notice Encodes an array of addresses to compact representation as a bytes array\\n     * @param args The array of LeveragedPool addresses to perform upkeep on\\n     * @return compact bytes array of addresses\\n     */\\n    function encodeAddressArray(address[] calldata args) external pure returns (bytes memory) {\\n        bytes memory encoded;\\n        uint256 len = args.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            encoded = bytes.concat(encoded, abi.encodePacked(args[i]));\\n        }\\n        return encoded;\\n    }\\n\\n    /**\\n     * @notice Encodes commit parameters from standard input to compact representation of 1 bytes32\\n     * @param amount Amount of settlement tokens you want to commit to minting; OR amount of pool\\n     *               tokens you want to burn\\n     * @param commitType Type of commit you're doing (Long vs Short, Mint vs Burn)\\n     * @param fromAggregateBalance If minting, burning, or rebalancing into a delta neutral position,\\n     *                             will tokens be taken from user's aggregate balance?\\n     * @param payForClaim True if user wants to pay for the commit to be claimed\\n     * @return compact representation of commit parameters\\n     */\\n    function encodeCommitParams(\\n        uint256 amount,\\n        IPoolCommitter.CommitType commitType,\\n        bool fromAggregateBalance,\\n        bool payForClaim\\n    ) external pure returns (bytes32) {\\n        uint128 shortenedAmount = amount.toUint128();\\n\\n        bytes32 res;\\n\\n        assembly {\\n            res := add(\\n                shortenedAmount,\\n                add(shl(128, commitType), add(shl(136, fromAggregateBalance), shl(144, payForClaim)))\\n            )\\n        }\\n        return res;\\n    }\\n}\\n\",\"keccak256\":\"0x26fedee463014acb9f6a72816562f3619ac23d78d90014c0ec916e8a5f51173a\",\"license\":\"CC-BY-NC-ND-4.0\"},\"contracts/interfaces/IPoolCommitter.sol\":{\"content\":\"//SPDX-License-Identifier: CC-BY-NC-ND-4.0\\npragma solidity 0.8.9;\\n\\n/// @title The interface for the contract that handles pool commitments\\ninterface IPoolCommitter {\\n    /// Type of commit\\n    enum CommitType {\\n        ShortMint, // Mint short tokens\\n        ShortBurn, // Burn short tokens\\n        LongMint, // Mint long tokens\\n        LongBurn, // Burn long tokens\\n        LongBurnShortMint, // Burn Long tokens, then instantly mint in same upkeep\\n        ShortBurnLongMint // Burn Short tokens, then instantly mint in same upkeep\\n    }\\n\\n    function isMint(CommitType t) external pure returns (bool);\\n\\n    function isBurn(CommitType t) external pure returns (bool);\\n\\n    function isLong(CommitType t) external pure returns (bool);\\n\\n    function isShort(CommitType t) external pure returns (bool);\\n\\n    // Pool balances and supplies\\n    struct BalancesAndSupplies {\\n        uint256 newShortBalance;\\n        uint256 newLongBalance;\\n        uint256 longMintPoolTokens;\\n        uint256 shortMintPoolTokens;\\n        uint256 longBurnInstantMintSettlement;\\n        uint256 shortBurnInstantMintSettlement;\\n        uint256 totalLongBurnPoolTokens;\\n        uint256 totalShortBurnPoolTokens;\\n    }\\n\\n    // User aggregate balance\\n    struct Balance {\\n        uint256 longTokens;\\n        uint256 shortTokens;\\n        uint256 settlementTokens;\\n    }\\n\\n    // Token Prices\\n    struct Prices {\\n        bytes16 longPrice;\\n        bytes16 shortPrice;\\n    }\\n\\n    // Commit information\\n    struct Commit {\\n        uint256 amount;\\n        CommitType commitType;\\n        uint40 created;\\n        address owner;\\n    }\\n\\n    // Commit information\\n    struct TotalCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n    }\\n\\n    // User updated aggregate balance\\n    struct BalanceUpdate {\\n        uint256 _updateIntervalId;\\n        uint256 _newLongTokensSum;\\n        uint256 _newShortTokensSum;\\n        uint256 _newSettlementTokensSum;\\n        uint256 _longSettlementFee;\\n        uint256 _shortSettlementFee;\\n        uint8 _maxIterations;\\n    }\\n\\n    // Track how much of a user's commitments are being done from their aggregate balance\\n    struct UserCommitment {\\n        uint256 longMintSettlement;\\n        uint256 longBurnPoolTokens;\\n        uint256 shortMintSettlement;\\n        uint256 shortBurnPoolTokens;\\n        uint256 shortBurnLongMintPoolTokens;\\n        uint256 longBurnShortMintPoolTokens;\\n        uint256 updateIntervalId;\\n    }\\n\\n    // Track the relevant data when executing a range of update interval's commitments (stack too deep)\\n    struct CommitmentExecutionTracking {\\n        uint256 longTotalSupply;\\n        uint256 shortTotalSupply;\\n        uint256 longTotalSupplyBefore;\\n        uint256 shortTotalSupplyBefore;\\n        uint256 _updateIntervalId;\\n    }\\n\\n    /**\\n     * @notice Creates a notification when a commit is created\\n     * @param user The user making the commitment\\n     * @param amount Amount of the commit\\n     * @param commitType Type of the commit (Short v Long, Mint v Burn)\\n     * @param appropriateUpdateIntervalId Id of update interval where this commit can be executed as part of upkeep\\n     * @param fromAggregateBalance whether or not to commit from aggregate (unclaimed) balance\\n     * @param payForClaim whether or not to request this commit be claimed automatically\\n     * @param mintingFee Minting fee at time of commit creation\\n     */\\n    event CreateCommit(\\n        address indexed user,\\n        uint256 indexed amount,\\n        CommitType indexed commitType,\\n        uint256 appropriateUpdateIntervalId,\\n        bool fromAggregateBalance,\\n        bool payForClaim,\\n        bytes16 mintingFee\\n    );\\n\\n    /**\\n     * @notice Creates a notification when a user's aggregate balance is updated\\n     */\\n    event AggregateBalanceUpdated(address indexed user);\\n\\n    /**\\n     * @notice Creates a notification when the PoolCommitter's leveragedPool address has been updated.\\n     * @param newPool the address of the new leveraged pool\\n     */\\n    event PoolChanged(address indexed newPool);\\n\\n    /**\\n     * @notice Creates a notification when commits for a given update interval are executed\\n     * @param updateIntervalId Unique identifier for the relevant update interval\\n     * @param burningFee Burning fee at the time of commit execution\\n     */\\n    event ExecutedCommitsForInterval(uint256 indexed updateIntervalId, bytes16 burningFee);\\n\\n    /**\\n     * @notice Creates a notification when a claim is made, depositing pool tokens in user's wallet\\n     */\\n    event Claim(address indexed user);\\n\\n    /*\\n     * @notice Creates a notification when the burningFee is updated\\n     */\\n    event BurningFeeSet(uint256 indexed _burningFee);\\n\\n    /**\\n     * @notice Creates a notification when the mintingFee is updated\\n     */\\n    event MintingFeeSet(uint256 indexed _mintingFee);\\n\\n    /**\\n     * @notice Creates a notification when the changeInterval is updated\\n     */\\n    event ChangeIntervalSet(uint256 indexed _changeInterval);\\n\\n    /**\\n     * @notice Creates a notification when the feeController is updated\\n     */\\n    event FeeControllerSet(address indexed _feeController);\\n\\n    // #### Functions\\n\\n    function initialize(\\n        address _factory,\\n        address _autoClaim,\\n        address _factoryOwner,\\n        address _feeController,\\n        address _invariantCheck,\\n        uint256 mintingFee,\\n        uint256 burningFee,\\n        uint256 _changeInterval\\n    ) external;\\n\\n    function commit(bytes32 args) external payable;\\n\\n    function updateIntervalId() external view returns (uint128);\\n\\n    function pendingMintSettlementAmount() external view returns (uint256);\\n\\n    function pendingShortBurnPoolTokens() external view returns (uint256);\\n\\n    function pendingLongBurnPoolTokens() external view returns (uint256);\\n\\n    function claim(address user) external;\\n\\n    function executeCommitments(\\n        uint256 lastPriceTimestamp,\\n        uint256 updateInterval,\\n        uint256 longBalance,\\n        uint256 shortBalance\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function updateAggregateBalance(address user) external;\\n\\n    function getAggregateBalance(address user) external view returns (Balance memory _balance);\\n\\n    function getAppropriateUpdateIntervalId() external view returns (uint128);\\n\\n    function setPool(address _leveragedPool) external;\\n\\n    function setBurningFee(uint256 _burningFee) external;\\n\\n    function setMintingFee(uint256 _mintingFee) external;\\n\\n    function setChangeInterval(uint256 _changeInterval) external;\\n\\n    function setFeeController(address _feeController) external;\\n}\\n\",\"keccak256\":\"0x3ca6c1ecf4adddd432451c3d8f3d41ffb19c2c7eff6d6a66b84b281a42235d52\",\"license\":\"CC-BY-NC-ND-4.0\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506103e3806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806302255e2a1461003b5780638da92a5d14610061575b600080fd5b61004e6100493660046101e4565b610081565b6040519081526020015b60405180910390f35b61007461006f366004610237565b6100aa565b60405161005891906102dc565b60008061008d86610155565b608086901b608886901b609086901b010101915050949350505050565b6060808260005b8181101561014b57828686838181106100cc576100cc61030f565b90506020020160208101906100e19190610325565b604051602001610109919060609190911b6bffffffffffffffffffffffff1916815260140190565b60408051601f19818403018152908290526101279291602001610355565b6040516020818303038152906040529250808061014390610384565b9150506100b1565b5090949350505050565b60006fffffffffffffffffffffffffffffffff8211156101cb5760405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20316044820152663238206269747360c81b606482015260840160405180910390fd5b5090565b803580151581146101df57600080fd5b919050565b600080600080608085870312156101fa57600080fd5b8435935060208501356006811061021057600080fd5b925061021e604086016101cf565b915061022c606086016101cf565b905092959194509250565b6000806020838503121561024a57600080fd5b823567ffffffffffffffff8082111561026257600080fd5b818501915085601f83011261027657600080fd5b81358181111561028557600080fd5b8660208260051b850101111561029a57600080fd5b60209290920196919550909350505050565b60005b838110156102c75781810151838201526020016102af565b838111156102d6576000848401525b50505050565b60208152600082518060208401526102fb8160408501602087016102ac565b601f01601f19169190910160400192915050565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561033757600080fd5b81356001600160a01b038116811461034e57600080fd5b9392505050565b600083516103678184602088016102ac565b83519083019061037b8183602088016102ac565b01949350505050565b60006000198214156103a657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220eeb08b76e42161d492d7fea6268ae979ed69fefb98a8ad25ac5e60750b227ed564736f6c63430008090033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806302255e2a1461003b5780638da92a5d14610061575b600080fd5b61004e6100493660046101e4565b610081565b6040519081526020015b60405180910390f35b61007461006f366004610237565b6100aa565b60405161005891906102dc565b60008061008d86610155565b608086901b608886901b609086901b010101915050949350505050565b6060808260005b8181101561014b57828686838181106100cc576100cc61030f565b90506020020160208101906100e19190610325565b604051602001610109919060609190911b6bffffffffffffffffffffffff1916815260140190565b60408051601f19818403018152908290526101279291602001610355565b6040516020818303038152906040529250808061014390610384565b9150506100b1565b5090949350505050565b60006fffffffffffffffffffffffffffffffff8211156101cb5760405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20316044820152663238206269747360c81b606482015260840160405180910390fd5b5090565b803580151581146101df57600080fd5b919050565b600080600080608085870312156101fa57600080fd5b8435935060208501356006811061021057600080fd5b925061021e604086016101cf565b915061022c606086016101cf565b905092959194509250565b6000806020838503121561024a57600080fd5b823567ffffffffffffffff8082111561026257600080fd5b818501915085601f83011261027657600080fd5b81358181111561028557600080fd5b8660208260051b850101111561029a57600080fd5b60209290920196919550909350505050565b60005b838110156102c75781810151838201526020016102af565b838111156102d6576000848401525b50505050565b60208152600082518060208401526102fb8160408501602087016102ac565b601f01601f19169190910160400192915050565b634e487b7160e01b600052603260045260246000fd5b60006020828403121561033757600080fd5b81356001600160a01b038116811461034e57600080fd5b9392505050565b600083516103678184602088016102ac565b83519083019061037b8183602088016102ac565b01949350505050565b60006000198214156103a657634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220eeb08b76e42161d492d7fea6268ae979ed69fefb98a8ad25ac5e60750b227ed564736f6c63430008090033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "encodeAddressArray(address[])": {
        "params": {
          "args": "The array of LeveragedPool addresses to perform upkeep on"
        },
        "returns": {
          "_0": "compact bytes array of addresses"
        }
      },
      "encodeCommitParams(uint256,uint8,bool,bool)": {
        "params": {
          "amount": "Amount of settlement tokens you want to commit to minting; OR amount of pool               tokens you want to burn",
          "commitType": "Type of commit you're doing (Long vs Short, Mint vs Burn)",
          "fromAggregateBalance": "If minting, burning, or rebalancing into a delta neutral position,                             will tokens be taken from user's aggregate balance?",
          "payForClaim": "True if user wants to pay for the commit to be claimed"
        },
        "returns": {
          "_0": "compact representation of commit parameters"
        }
      }
    },
    "title": "L2Encoder",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "encodeAddressArray(address[])": {
        "notice": "Encodes an array of addresses to compact representation as a bytes array"
      },
      "encodeCommitParams(uint256,uint8,bool,bool)": {
        "notice": "Encodes commit parameters from standard input to compact representation of 1 bytes32"
      }
    },
    "notice": "Helper contract to encode calldata, used to optimize calldata size only indented to help generate calldata for uses/frontends.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}